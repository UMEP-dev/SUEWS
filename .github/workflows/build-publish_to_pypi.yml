name: Build and Publish Python wheels to PyPI and TestPyPI

# ============================================================================
# WORKFLOW OVERVIEW
# ============================================================================
# This workflow handles all Python package builds and deployments for SUEWS/SuPy.
#
# TRIGGERS:
# - Nightly: 2 AM UTC daily for development releases
# - Push: To master branch or any tag
# - PR: On pull requests for validation
# - Manual: Via workflow_dispatch
#
# DEPLOYMENT STRATEGY:
# 1. VALIDATION ONLY (no deployment):
#    - Pull requests: Build and test all Python versions
#    - Push to master: Build and test all Python versions
#    - Manual workflow_dispatch: Build and test all Python versions
#
# 2. DEVELOPMENT RELEASES (TestPyPI only):
#    - Nightly cron (2 AM UTC, master branch only): Creates YYYY.M.D.dev tag → TestPyPI
#    - Any tag containing 'dev': Deploy to TestPyPI
#    Installation:
#      Latest dev: pip install -i https://test.pypi.org/simple/ supy
#      Specific version: pip install -i https://test.pypi.org/simple/ supy==YYYY.M.D.dev0
#
# 3. PRODUCTION RELEASES (PyPI only):
#    - Tags without 'dev': Deploy to PyPI
#    Installation: pip install supy
#
# ============================================================================
# VERSIONING SYSTEM FOR NIGHTLY BUILDS
# ============================================================================
# Tag Format: YYYY.M.D.dev (e.g., 2025.8.17.dev)
# Published Version: YYYY.M.D.devN where N is commit count since tag
#   - At tag: 2025.8.17.dev0
#   - After 2 commits: 2025.8.17.dev2
#
# CRITICAL: Tag MUST be created BEFORE building wheels to ensure version consistency.
# Previously, creating tags after builds caused version mismatches where Aug 16 builds
# would use Aug 15 tag + commits, resulting in wrong version numbers on TestPyPI.
#
# WORKFLOW ORDER (for nightly builds):
# 1. create_nightly_tag: Creates today's tag (e.g., 2025.8.17.dev)
# 2. build_wheels: Builds using the new tag (produces 2025.8.17.dev0)
# 3. deploy_testpypi: Publishes correct version to TestPyPI
#
# RESILIENCE FEATURES:
# - Tags created even if some platform builds fail (maintains consecutive dates)
# - TestPyPI deployment proceeds with available wheels
# - Prevents gaps in nightly build sequence
#
# Build matrix: Always builds all Python versions (3.9-3.13) on all platforms
#
# ============================================================================
# UMEP/QGIS COMPATIBILITY BUILDS (rc1 pre-release versions)
# ============================================================================
# Every formal release tag automatically creates TWO PyPI versions:
#
# 1. STANDARD BUILD (build_wheels job):
#    - Tag: v2024.10.7
#    - Version: 2024.10.7
#    - NumPy: >=2.0 (build and runtime)
#    - Target: Standalone Python users
#    - Public facing, documented
#    - pip install supy → gets this version
#
# 2. UMEP BUILD (build_umep job):
#    - Tag: v2024.10.7 (same tag)
#    - Version: 2024.10.7rc1
#    - NumPy: oldest-supported-numpy (build), >=1.22,<2.0 (runtime)
#    - Target: QGIS 3.40 LTR (NumPy 1.26.4) / UMEP plugin users
#    - Undocumented publicly, for UMEP requirements files only
#    - Pre-release tag (rc1) ensures pip skips it by default
#
# AUTOMATIC DUAL BUILD PROCESS:
# - Jobs run in parallel for efficiency
# - BUILD_UMEP_VARIANT env var triggers rc1 suffix in get_ver_git.py
# - pyproject.toml modified for NumPy 1.x at build time
# - Both wheel sets deployed to PyPI together
#
# UMEP INTEGRATION:
# - UMEP requirements specify: supy==2024.10.7rc1
# - UMEP users install via UMEP requirements, never see version details
# - No coordination needed - rc1 always exists for every production release
#
# VERSIONING:
# - rc1 is PEP 440 compliant pre-release version (release candidate 1)
# - Pre-releases are skipped by default: pip install supy → 2024.10.7 (not rc1)
# - Indicates alternative build config (NumPy 1.x), not unstable software
# - See get_ver_git.py for version string logic
# ============================================================================

on:
  push:
    branches: [master]
    tags:
      - '*'  # Trigger on any tag push
    paths: # Push events containing matching files
      - "src/suews/**"
      - "src/supy/**"
      - "src/supy_driver/**"
      - ".github/workflows/build-publish_to_pypi.yml"
      - "test/**"
      - "pyproject.toml"
      - "meson.build"
      - "Makefile"

  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
    paths: # PR events containing matching files
      - "src/suews/**"
      - "src/supy/**"
      - "src/supy_driver/**"
      - ".github/workflows/build-publish_to_pypi.yml"
      - "test/**"
      - "pyproject.toml"
      - "meson.build"
      - "Makefile"

  schedule:
    # Run nightly builds at 2 AM UTC
    - cron: '0 2 * * *'

  workflow_dispatch:

# Cancel in-progress runs when new commits are pushed to the same PR/branch
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  # Create nightly tag BEFORE building to ensure correct version
  create_nightly_tag:
    name: Create nightly tag for scheduled builds
    runs-on: ubuntu-latest
    # Only run for scheduled (nightly) builds
    if: github.event_name == 'schedule'
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create and push nightly tag
        run: |
          set -e

          # Get the current date in YYYY.M.D format (without leading zeros as requested)
          YEAR=$(date -u +%Y)
          MONTH=$(date -u +%-m)  # Without leading zero
          DAY=$(date -u +%-d)    # Without leading zero

          # Create a dev tag for the nightly build
          DEV_TAG="${YEAR}.${MONTH}.${DAY}.dev"
          echo "Creating dev tag: ${DEV_TAG}"

          # Configure git
          git config user.name github-actions
          git config user.email github-actions@github.com

          # Check if tag already exists
          if git ls-remote --tags origin | grep -q "refs/tags/${DEV_TAG}"; then
            echo "Tag ${DEV_TAG} already exists on remote, skipping tag creation"
          else
            # Create and push the tag
            git tag -a "${DEV_TAG}" -m "Nightly build ${YEAR}-${MONTH}-${DAY}"
            git push origin "${DEV_TAG}"
            echo "Successfully created and pushed tag ${DEV_TAG}"
          fi

  # Determine if we should run limited or full matrix
  determine_matrix:
    name: Determine build matrix
    runs-on: ubuntu-latest
    outputs:
      buildplat: ${{ steps.set-matrix.outputs.buildplat }}
      python: ${{ steps.set-matrix.outputs.python }}
    steps:
      - name: Set matrix based on draft status
        id: set-matrix
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]] && [[ "${{ github.event.pull_request.draft }}" == "true" ]]; then
            echo "Running limited matrix for draft PR"
            echo 'buildplat=[["ubuntu-latest", "manylinux", "x86_64"]]' >> $GITHUB_OUTPUT
            echo 'python=["cp39", "cp313"]' >> $GITHUB_OUTPUT
          else
            echo "Running full matrix"
            echo 'buildplat=[["ubuntu-latest", "manylinux", "x86_64"], ["macos-13", "macosx", "x86_64"], ["macos-latest", "macosx", "arm64"], ["windows-2025", "win", "AMD64"]]' >> $GITHUB_OUTPUT
            echo 'python=["cp39", "cp310", "cp311", "cp312", "cp313"]' >> $GITHUB_OUTPUT
          fi

  build_wheels:
    name: Build wheel for ${{ matrix.python }}-${{ matrix.buildplat[1] }} ${{ matrix.buildplat[2] }}
    runs-on: ${{ matrix.buildplat[0] }}
    needs: [determine_matrix, create_nightly_tag]
    # Run if: not a scheduled build, OR if it's scheduled and tag was created/skipped
    if: |
      always() &&
      needs.determine_matrix.result == 'success' &&
      (needs.create_nightly_tag.result == 'success' || needs.create_nightly_tag.result == 'skipped')
    strategy:
      matrix:
        buildplat: ${{ fromJson(needs.determine_matrix.outputs.buildplat) }}
        python: ${{ fromJson(needs.determine_matrix.outputs.python) }}

      fail-fast: false
    env:
      IS_32_BIT: ${{ matrix.buildplat[2] == 'x86' }}
      WHEEL_NAME: ${{ matrix.python }}-${{ matrix.buildplat[1] }}-${{ matrix.buildplat[2] }}
      CIBW_BUILD: ${{ matrix.python }}-${{ matrix.buildplat[1] }}*
      CIBW_ARCHS: ${{ matrix.buildplat[2] }}
      CIBW_ENVIRONMENT_PASS_LINUX: RUNNER_OS
      # Use manylinux2014 for compatibility with older Linux systems (glibc 2.17+)
      # This is critical for HPC clusters and older distributions
      CIBW_MANYLINUX_X86_64_IMAGE: manylinux2014
      CIBW_MANYLINUX_AARCH64_IMAGE: manylinux2014
      # Configure pip to use binary wheels and avoid building from source
      # For Python 3.13, allow building f90wrap from source since no wheels exist
      # Also set Fortran flags for line length handling
      CIBW_ENVIRONMENT_LINUX: >
        PIP_PREFER_BINARY=1
        PIP_ONLY_BINARY=${{ matrix.python == 'cp313' && 'pyarrow' || ':all:' }}
        FCFLAGS="-fno-optimize-sibling-calls -ffree-line-length-none"
        F90=gfortran
      CIBW_BEFORE_ALL_LINUX: >
        pip install --upgrade pip setuptools wheel &&
        pip install oldest-supported-numpy &&
        if [[ "${{ matrix.python }}" == "cp313" ]]; then
          echo "Installing numpy for Python 3.13 f90wrap build" &&
          pip install numpy;
        fi
      CIBW_BEFORE_ALL_MACOS: >
        brew install gfortran &&
        brew unlink gfortran &&
        brew link gfortran
      CIBW_BEFORE_ALL_WINDOWS: >
        C:\msys64\usr\bin\bash.exe -lc "pacman -Syu --noconfirm" &&
        C:\msys64\usr\bin\bash.exe -lc "pacman -S --needed --noconfirm mingw-w64-ucrt-x86_64-gcc mingw-w64-ucrt-x86_64-gcc-fortran mingw-w64-ucrt-x86_64-binutils mingw-w64-ucrt-x86_64-make mingw-w64-ucrt-x86_64-openblas"
      CIBW_ENVIRONMENT_WINDOWS: >
        PATH="C:\\msys64\\ucrt64\\bin;$PATH"
        CC=gcc
        CXX=g++
        FC=gfortran
        CFLAGS="-D__USE_MINGW_ANSI_STDIO=1 -mlong-double-64"
        CXXFLAGS="-D__USE_MINGW_ANSI_STDIO=1 -mlong-double-64"
        FCFLAGS="-fno-optimize-sibling-calls -ffree-line-length-none"
        LDFLAGS="-lucrt -static-libgcc -static-libgfortran -LC:/msys64/ucrt64/lib -lsetjmp_compat"
      CIBW_BEFORE_BUILD_WINDOWS: >
        echo Creating setjmp compatibility library... &&
        echo int _setjmpex(void* buf) { extern int __intrinsic_setjmpex(void*); return __intrinsic_setjmpex(buf); } > setjmp_compat.c &&
        C:\msys64\ucrt64\bin\gcc.exe -c setjmp_compat.c -o setjmp_compat.o &&
        C:\msys64\ucrt64\bin\ar.exe rcs libsetjmp_compat.a setjmp_compat.o &&
        echo Library created, checking contents: &&
        C:\msys64\ucrt64\bin\nm.exe libsetjmp_compat.a &&
        echo Copying to standard locations: &&
        copy libsetjmp_compat.a C:\msys64\ucrt64\lib\ &&
        copy libsetjmp_compat.a C:\msys64\ucrt64\x86_64-w64-mingw32\lib\ &&
        echo Verifying library locations: &&
        dir C:\msys64\ucrt64\lib\libsetjmp_compat.a &&
        dir C:\msys64\ucrt64\x86_64-w64-mingw32\lib\libsetjmp_compat.a &&
        where python &&
        where gcc &&
        gcc --version &&
        pip install delvewheel
      CIBW_REPAIR_WHEEL_COMMAND_WINDOWS: "delvewheel repair -w {dest_dir} {wheel}"
      CIBW_TEST_REQUIRES: pytest
      CIBW_TEST_COMMAND: "python -m pytest {project}/test -v --tb=short --durations=10"
      MACOSX_DEPLOYMENT_TARGET: ${{ matrix.buildplat[0] == 'macos-13' && '13.0' || '15.0' }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
            python-version: 3.12

      - name: Build wheels
        uses: pypa/cibuildwheel@v3.0.0

      - name: upload wheels
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.WHEEL_NAME }}
          path: ./wheelhouse/*.whl

  build_umep:
    name: Build UMEP wheel (rc1) for ${{ matrix.python }}-${{ matrix.buildplat[1] }} ${{ matrix.buildplat[2] }}
    runs-on: ${{ matrix.buildplat[0] }}
    needs: [determine_matrix, create_nightly_tag]
    # Only run for production tags (not dev, not PRs, not nightly)
    if: |
      startsWith(github.ref, 'refs/tags/') &&
      !contains(github.ref, 'dev') &&
      needs.determine_matrix.result == 'success' &&
      (needs.create_nightly_tag.result == 'success' || needs.create_nightly_tag.result == 'skipped')
    strategy:
      matrix:
        buildplat: ${{ fromJson(needs.determine_matrix.outputs.buildplat) }}
        python: ${{ fromJson(needs.determine_matrix.outputs.python) }}

      fail-fast: false
    env:
      IS_32_BIT: ${{ matrix.buildplat[2] == 'x86' }}
      WHEEL_NAME: ${{ matrix.python }}-${{ matrix.buildplat[1] }}-${{ matrix.buildplat[2] }}-umep
      BUILD_UMEP_VARIANT: 'true'  # Triggers rc1 suffix in get_ver_git.py
      CIBW_BUILD: ${{ matrix.python }}-${{ matrix.buildplat[1] }}*
      CIBW_ARCHS: ${{ matrix.buildplat[2] }}
      CIBW_ENVIRONMENT_PASS_LINUX: RUNNER_OS BUILD_UMEP_VARIANT
      # Use manylinux2014 for compatibility with older Linux systems (glibc 2.17+)
      CIBW_MANYLINUX_X86_64_IMAGE: manylinux2014
      CIBW_MANYLINUX_AARCH64_IMAGE: manylinux2014
      # Configure pip to use binary wheels and avoid building from source
      CIBW_ENVIRONMENT_LINUX: >
        PIP_PREFER_BINARY=1
        PIP_ONLY_BINARY=${{ matrix.python == 'cp313' && 'pyarrow' || ':all:' }}
        FCFLAGS="-fno-optimize-sibling-calls -ffree-line-length-none"
        F90=gfortran
        BUILD_UMEP_VARIANT=true
      CIBW_BEFORE_ALL_LINUX: >
        pip install --upgrade pip setuptools wheel &&
        pip install oldest-supported-numpy &&
        if [[ "${{ matrix.python }}" == "cp313" ]]; then
          echo "Installing numpy for Python 3.13 f90wrap build" &&
          pip install numpy;
        fi
      CIBW_BEFORE_ALL_MACOS: >
        brew install gfortran &&
        brew unlink gfortran &&
        brew link gfortran
      CIBW_BEFORE_ALL_WINDOWS: >
        C:\msys64\usr\bin\bash.exe -lc "pacman -Syu --noconfirm" &&
        C:\msys64\usr\bin\bash.exe -lc "pacman -S --needed --noconfirm mingw-w64-ucrt-x86_64-gcc mingw-w64-ucrt-x86_64-gcc-fortran mingw-w64-ucrt-x86_64-binutils mingw-w64-ucrt-x86_64-make mingw-w64-ucrt-x86_64-openblas"
      CIBW_ENVIRONMENT_WINDOWS: >
        PATH="C:\\msys64\\ucrt64\\bin;$PATH"
        CC=gcc
        CXX=g++
        FC=gfortran
        CFLAGS="-D__USE_MINGW_ANSI_STDIO=1 -mlong-double-64"
        CXXFLAGS="-D__USE_MINGW_ANSI_STDIO=1 -mlong-double-64"
        FCFLAGS="-fno-optimize-sibling-calls -ffree-line-length-none"
        LDFLAGS="-lucrt -static-libgcc -static-libgfortran -LC:/msys64/ucrt64/lib -lsetjmp_compat"
        BUILD_UMEP_VARIANT=true
      CIBW_BEFORE_BUILD_WINDOWS: >
        echo Creating setjmp compatibility library... &&
        echo int _setjmpex(void* buf) { extern int __intrinsic_setjmpex(void*); return __intrinsic_setjmpex(buf); } > setjmp_compat.c &&
        C:\msys64\ucrt64\bin\gcc.exe -c setjmp_compat.c -o setjmp_compat.o &&
        C:\msys64\ucrt64\bin\ar.exe rcs libsetjmp_compat.a setjmp_compat.o &&
        echo Library created, checking contents: &&
        C:\msys64\ucrt64\bin\nm.exe libsetjmp_compat.a &&
        echo Copying to standard locations: &&
        copy libsetjmp_compat.a C:\msys64\ucrt64\lib\ &&
        copy libsetjmp_compat.a C:\msys64\ucrt64\x86_64-w64-mingw32\lib\ &&
        echo Verifying library locations: &&
        dir C:\msys64\ucrt64\lib\libsetjmp_compat.a &&
        dir C:\msys64\ucrt64\x86_64-w64-mingw32\lib\libsetjmp_compat.a &&
        where python &&
        where gcc &&
        gcc --version &&
        pip install delvewheel
      CIBW_REPAIR_WHEEL_COMMAND_WINDOWS: "delvewheel repair -w {dest_dir} {wheel}"
      CIBW_TEST_REQUIRES: pytest
      CIBW_TEST_COMMAND: "python -m pytest {project}/test -v --tb=short --durations=10"
      MACOSX_DEPLOYMENT_TARGET: ${{ matrix.buildplat[0] == 'macos-13' && '13.0' || '15.0' }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Modify pyproject.toml for NumPy 1.x compatibility
        run: |
          echo "Building UMEP variant with NumPy 1.x compatibility"

          # Build-time: Use oldest-supported-numpy for binary compatibility
          sed -i.bak 's/"numpy>=2\.0"/"oldest-supported-numpy"/g' pyproject.toml

          # Runtime: Pin to NumPy 1.x (QGIS 3.40 LTR uses 1.26.4)
          sed -i.bak 's/"numpy>=2\.0",/"numpy>=1.22,<2.0",/g' pyproject.toml

          echo "Modified pyproject.toml for UMEP build:"
          git diff pyproject.toml || true

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
            python-version: 3.12

      - name: Build wheels
        uses: pypa/cibuildwheel@v3.0.0

      - name: upload wheels
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.WHEEL_NAME }}
          path: ./wheelhouse/*.whl

  test_numpy_compat:
    name: Test NumPy 1.x compatibility (UMEP/QGIS)
    runs-on: ubuntu-latest
    # Only run for production tags to validate UMEP builds
    if: startsWith(github.ref, 'refs/tags/') && !contains(github.ref, 'dev')

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install with NumPy 1.26.4 (QGIS 3.40 LTR version)
        run: |
          # Install NumPy 1.26.4 first (same as QGIS 3.40 LTR)
          pip install numpy==1.26.4

          # Modify pyproject.toml as UMEP build does
          sed -i 's/"numpy>=2\.0"/"oldest-supported-numpy"/g' pyproject.toml
          sed -i 's/"numpy>=2\.0",/"numpy>=1.22,<2.0",/g' pyproject.toml

          # Install in editable mode
          pip install -e .

          # Verify NumPy version
          python -c "import numpy; print(f'NumPy version: {numpy.__version__}')"
          python -c "import supy; print(f'SuPy version: {supy.__version__}')"

      - name: Run test suite with NumPy 1.x
        run: |
          pytest test/ -v --tb=short --durations=10

  deploy_testpypi:
    name: Publish to TestPyPI
    runs-on: ubuntu-latest
    needs:
      - determine_matrix
      - build_wheels
      - create_nightly_tag  # Will be skipped for non-nightly builds
    # Deploy to TestPyPI for nightly builds even if some platforms fail
    # This ensures continuous availability of development builds
    if: |
      always() &&
      needs.build_wheels.result != 'cancelled' &&
      (needs.create_nightly_tag.result == 'success' || needs.create_nightly_tag.result == 'skipped') &&
      (
        github.event_name == 'schedule' ||
        (startsWith(github.ref, 'refs/tags/') && contains(github.ref, 'dev'))
      )

    # Set up permissions for OIDC authentication
    permissions:
      id-token: write  # Required for Trusted Publishing

    steps:
      - name: Download all wheels for TestPyPI
        uses: actions/download-artifact@v4
        with:
          path: dist/
          merge-multiple: true

      - name: Publish wheels to Test PyPI
        uses: pypa/gh-action-pypi-publish@release/v1.8
        with:
          packages-dir: dist/
          verbose: true
          skip-existing: true
          repository-url: https://test.pypi.org/legacy/

  deploy_pypi:
    name: Publish all wheels to PyPI
    runs-on: ubuntu-latest
    needs:
      - determine_matrix
      - build_wheels
      - build_umep  # UMEP builds (.post1 variants)
      - create_nightly_tag  # Will be skipped for non-nightly builds
    # Only run for tagged releases WITHOUT 'dev' in the tag name
    # Deploy if either standard OR UMEP build succeeds (or both)
    if: |
      always() &&
      startsWith(github.ref, 'refs/tags') &&
      !contains(github.ref, 'dev') &&
      (needs.build_wheels.result == 'success' || needs.build_umep.result == 'success') &&
      (needs.create_nightly_tag.result == 'success' || needs.create_nightly_tag.result == 'skipped')

    # Set up permissions for OIDC authentication
    permissions:
      id-token: write  # Required for Trusted Publishing

    steps:
      - name: Download all the built wheels (standard + UMEP)
        uses: actions/download-artifact@v4
        with:
          path: dist/
          merge-multiple: true

      - name: Publish all wheels to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1.8
        with:
          packages-dir: dist/
          verbose: true
          skip-existing: true

  create_github_release:
    name: Create GitHub Release (triggers Zenodo)
    runs-on: ubuntu-latest
    needs:
      - deploy_pypi
    # Only run for production releases (not dev/rc)
    if: |
      needs.deploy_pypi.result == 'success' &&
      startsWith(github.ref, 'refs/tags/') &&
      !contains(github.ref, 'dev') &&
      !contains(github.ref, 'rc')

    permissions:
      contents: write  # Required to create releases

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract version from tag
        id: get_version
        run: |
          VERSION=${GITHUB_REF#refs/tags/}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Extract changelog for this version
        id: changelog
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"

          # Extract the date from version (YYYY.M.D format)
          YEAR=$(echo $VERSION | cut -d. -f1)
          MONTH=$(echo $VERSION | cut -d. -f2)
          DAY=$(echo $VERSION | cut -d. -f3)

          # Try different date formats in CHANGELOG.md
          # Format: "### D MMM YYYY" or "### DD MMM YYYY"
          MONTH_NAME=$(date -d "$YEAR-$MONTH-$DAY" +"%b" 2>/dev/null || date -j -f "%Y-%m-%d" "$YEAR-$MONTH-$DAY" +"%b" 2>/dev/null || echo "")

          if [ -n "$MONTH_NAME" ]; then
            # Try with and without leading zero
            CHANGELOG_SECTION=$(awk "/^### $DAY $MONTH_NAME $YEAR/,/^### [0-9]/" CHANGELOG.md | sed '$d' || echo "")
            if [ -z "$CHANGELOG_SECTION" ]; then
              # Try with zero-padded day
              DAY_PADDED=$(printf "%02d" $DAY)
              CHANGELOG_SECTION=$(awk "/^### $DAY_PADDED $MONTH_NAME $YEAR/,/^### [0-9]/" CHANGELOG.md | sed '$d' || echo "")
            fi
          fi

          if [ -z "$CHANGELOG_SECTION" ]; then
            CHANGELOG_SECTION="See [CHANGELOG.md](https://github.com/UMEP-dev/SUEWS/blob/master/CHANGELOG.md) for details."
          fi

          # Save to file for multiline content
          echo "$CHANGELOG_SECTION" > changelog_section.txt

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          CHANGELOG=$(cat changelog_section.txt)

          # Create release notes
          cat << EOF > release_notes.md
          ## Installation
          \`\`\`bash
          pip install --upgrade supy
          \`\`\`

          ## Changes

          $CHANGELOG

          ## Citation

          This release is automatically archived on Zenodo and assigned a DOI for academic citation. The DOI will appear here once Zenodo processing is complete (usually within a few minutes).

          ## Documentation

          - [User Guide](https://suews.readthedocs.io)
          - [CHANGELOG](https://github.com/UMEP-dev/SUEWS/blob/master/CHANGELOG.md)
          - [GitHub Repository](https://github.com/UMEP-dev/SUEWS)
          EOF

          # Extract title from tag annotation if available
          TITLE=$(git tag -l --format='%(contents:subject)' "$VERSION" || echo "SUEWS Release")

          # Create the release
          gh release create "$VERSION" \
            --title "SUEWS v$VERSION: $TITLE" \
            --notes-file release_notes.md \
            --verify-tag

