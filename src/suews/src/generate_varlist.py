#!/usr/bin/env python3
"""Generate Fortran varListAll DATA statements from Python OUTPUT_REGISTRY.

This script makes Python the single source of truth for output variable definitions,
eliminating duplication between Python and Fortran code.

The generated Fortran code can be included in suews_ctrl_output.f95 using:
    INCLUDE 'varlist_generated.f95'

This approach allows:
- Python/Pydantic as single source of truth
- Automatic Fortran code generation at build time
- No manual maintenance of Fortran variable lists
- Eventual deprecation of manual Fortran definitions
"""

import sys
import os
from pathlib import Path

# Add src/supy/data_model to path to avoid importing full supy package
data_model_path = Path(__file__).parent.parent.parent / "supy" / "data_model"
sys.path.insert(0, str(data_model_path))

# Direct import from output module (minimal dependencies)
from output import OUTPUT_REGISTRY, OutputGroup


def escape_fortran_string(s: str, max_len: int) -> str:
    """Escape and truncate string for Fortran character literal.

    Args:
        s: String to escape
        max_len: Maximum length for Fortran character variable

    Returns:
        Escaped and truncated string safe for Fortran
    """
    # Replace any single quotes with doubled quotes (Fortran escape)
    escaped = s.replace("'", "''")

    # Truncate if needed
    if len(escaped) > max_len:
        escaped = escaped[:max_len]

    return escaped


def format_fortran_varattr(var, index: int) -> str:
    """Format a single OutputVariable as Fortran varAttr constructor.

    Args:
        var: OutputVariable instance
        index: Variable index in array (1-based)

    Returns:
        Fortran varAttr constructor call string
    """
    # Get string values from enums
    group_val = var.group.value if hasattr(var.group, 'value') else var.group
    aggm_val = var.aggregation.value if hasattr(var.aggregation, 'value') else var.aggregation
    level_val = var.level.value if hasattr(var.level, 'value') else var.level

    # Escape and truncate strings to match Fortran type limits
    # TYPE varAttr has: header(20), unit(12), fmt(10), longNm(100), aggreg(1), group(10), level(int)
    header = escape_fortran_string(var.name, 20)
    unit = escape_fortran_string(var.unit, 12)
    fmt = escape_fortran_string(var.format, 10)
    longNm = escape_fortran_string(var.description, 100)
    aggreg = escape_fortran_string(aggm_val, 1)
    group = escape_fortran_string(group_val, 10)

    return f"      varAttr('{header}', '{unit}', '{fmt}', '{longNm}', '{aggreg}', '{group}', {level_val})"


def generate_fortran_data_statements() -> str:
    """Generate Fortran DATA statements for all variables in OUTPUT_REGISTRY.

    Returns:
        Complete Fortran code for varListAll initialization
    """
    lines = []

    # Add header comment
    lines.append("!==============================================================================")
    lines.append("! AUTO-GENERATED FILE - DO NOT EDIT MANUALLY")
    lines.append("! Generated by: src/suews/src/generate_varlist.py")
    lines.append("! Source: src/supy/data_model/output/__init__.py (OUTPUT_REGISTRY)")
    lines.append("!")
    lines.append("! This file contains DATA statements initializing the varListAll array")
    lines.append("! from Python/Pydantic OUTPUT_REGISTRY definitions.")
    lines.append("!")
    lines.append("! To regenerate: run generate_varlist.py or rebuild with meson")
    lines.append("!==============================================================================")
    lines.append("")

    # Group variables by OutputGroup for cleaner organization
    group_order = [
        OutputGroup.DATETIME,
        OutputGroup.SUEWS,
        OutputGroup.SNOW,
        OutputGroup.ESTM,
        OutputGroup.RSL,
        OutputGroup.DAILYSTATE,
        OutputGroup.BL,
        OutputGroup.BEERS,
        OutputGroup.DEBUG,
    ]

    current_index = 1

    for group in group_order:
        group_vars = OUTPUT_REGISTRY.by_group(group)

        if not group_vars:
            continue

        # Add comment for this group
        group_name = group.value if hasattr(group, 'value') else str(group)
        lines.append(f"   ! {group_name} variables ({len(group_vars)} variables)")

        # Calculate range for this DATA statement
        start_idx = current_index
        end_idx = current_index + len(group_vars) - 1

        # Generate DATA statement
        lines.append(f"   DATA(varListAll(n), &")
        lines.append(f"        n={start_idx}, {end_idx})/ &")

        # Add variable definitions
        for i, var in enumerate(group_vars):
            var_def = format_fortran_varattr(var, current_index)

            # Add comma and continuation for all but last variable
            if i < len(group_vars) - 1:
                lines.append(var_def + ", &")
            else:
                lines.append(var_def + " &")

        # Close DATA statement
        lines.append("      /")
        lines.append("")

        current_index = end_idx + 1

    # Add summary comment
    total_vars = len(OUTPUT_REGISTRY.variables)
    lines.append(f"   ! Total variables defined: {total_vars}")
    lines.append(f"   ! Array size: {current_index - 1} (rest unused)")
    lines.append("")

    return "\n".join(lines)


def main():
    """Generate Fortran varListAll DATA statements and write to file."""
    # Generate output file path (same directory as this script)
    output_path = Path(__file__).parent / "varlist_generated.f95"

    print(f"Generating Fortran varListAll DATA statements...")
    print(f"Reading from: OUTPUT_REGISTRY ({len(OUTPUT_REGISTRY.variables)} variables)")

    # Generate Fortran code
    fortran_code = generate_fortran_data_statements()

    # Write to file
    with open(output_path, 'w') as f:
        f.write(fortran_code)

    print(f"âœ“ Generated: {output_path}")
    print(f"  Lines: {len(fortran_code.splitlines())}")
    print(f"  Variables: {len(OUTPUT_REGISTRY.variables)}")

    # Print summary by group
    print("\nVariable counts by group:")
    for group in [
        OutputGroup.DATETIME, OutputGroup.SUEWS, OutputGroup.SNOW,
        OutputGroup.ESTM, OutputGroup.RSL, OutputGroup.DAILYSTATE,
        OutputGroup.BL, OutputGroup.BEERS, OutputGroup.DEBUG
    ]:
        count = len(OUTPUT_REGISTRY.by_group(group))
        group_name = group.value if hasattr(group, 'value') else str(group)
        print(f"  - {group_name}: {count}")

    return 0


if __name__ == "__main__":
    sys.exit(main())
