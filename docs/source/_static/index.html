<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SUEWS Config Editor</title>

  <!-- Bootstrap CSS -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css"
  />

  <!-- Optional: Font Awesome for icons -->
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
    integrity="sha512-Fo3rlrZj/k7ujTnHg4CGR2DhKNQbZdf02F+T7O3r8hdt6K0ASYPKb3OJ9N6nXl0y1hCAKZLUnFiiQeY8ql8zaQ=="
    crossorigin="anonymous"
    referrerpolicy="no-referrer"
  />

  <!-- AJV for JSON Schema validation -->
  <script
    src="https://cdnjs.cloudflare.com/ajax/libs/ajv/8.12.0/ajv7.min.js"
    integrity="sha512-lfgrViOH1Ug5C3+W9LNc/wec0nVkVSAIDmAU0uObKJ53sc+ic+ZcC7xxqXHHZPcwcoPuhK/knpqPLJAktwc0YQ=="
    crossorigin="anonymous"
    referrerpolicy="no-referrer"
  ></script>

  <style>
    body {
      background-color: #f8f9fa;
    }
    .required::after {
      content: " *";
      color: red;
    }
    .schema-section {
      border: 1px solid #ccc;
      border-radius: 0.5rem;
      margin-bottom: 15px;
      padding: 15px;
    }
    .schema-section h4 {
      cursor: pointer;
      margin-bottom: 0;
    }
    .error-list {
      color: #dc3545;
      font-size: 0.9rem;
    }
    .nav-tabs .nav-link.active {
      background-color: #e9ecef;
      border-color: #dee2e6 #dee2e6 #fff;
    }
    .toggle-icon {
      float: right;
      transition: transform 0.3s ease;
    }
    .toggle-icon.collapsed {
      transform: rotate(-90deg);
    }
    .small-desc {
      font-size: 0.85rem;
      color: #6c757d;
    }
    .hidden {
      display: none;
    }
  </style>
</head>

<body class="container py-4">
  <h1 class="mb-4">SUEWS Config Editor</h1>
  <p class="mb-4 text-muted">
    This page helps you fill in the parameters for a SUEWS configuration JSON.
    It uses the <code>suews-config-schema.json</code> for validation. You can
    import/export JSON, or fill in step by step. All changes are kept in
    memory; be sure to <strong>export</strong> for safe keeping.
  </p>

  <!-- Nav Tabs for multi-section layout -->
  <ul class="nav nav-tabs mb-3" id="mainTab" role="tablist">
    <li class="nav-item" role="presentation">
      <button
        class="nav-link active"
        id="form-tab"
        data-bs-toggle="tab"
        data-bs-target="#form-section"
        type="button"
        role="tab"
        aria-controls="form-section"
        aria-selected="true"
      >
        Form
      </button>
    </li>
    <li class="nav-item" role="presentation">
      <button
        class="nav-link"
        id="json-tab"
        data-bs-toggle="tab"
        data-bs-target="#json-section"
        type="button"
        role="tab"
        aria-controls="json-section"
        aria-selected="false"
      >
        Raw JSON
      </button>
    </li>
    <li class="nav-item" role="presentation">
      <button
        class="nav-link"
        id="validate-tab"
        data-bs-toggle="tab"
        data-bs-target="#validate-section"
        type="button"
        role="tab"
        aria-controls="validate-section"
        aria-selected="false"
      >
        Validation
      </button>
    </li>
  </ul>

  <div class="tab-content" id="mainTabContent">
    <!-- Form Tab -->
    <div
      class="tab-pane fade show active"
      id="form-section"
      role="tabpanel"
      aria-labelledby="form-tab"
    >
      <div id="form-container" class="mb-3"></div>
      <div class="d-flex gap-2">
        <button id="export-json" class="btn btn-success">
          <i class="fas fa-file-export"></i> Export JSON
        </button>
        <label for="import-json" class="btn btn-primary mb-0">
          <i class="fas fa-file-import"></i> Import JSON
        </label>
        <input
          type="file"
          id="import-json"
          accept=".json"
          class="d-none"
        />
      </div>
    </div>

    <!-- Raw JSON Tab -->
    <div
      class="tab-pane fade"
      id="json-section"
      role="tabpanel"
      aria-labelledby="json-tab"
    >
      <div class="mb-3">
        <textarea
          id="json-view"
          class="form-control"
          rows="20"
          placeholder="JSON view"
        ></textarea>
      </div>
      <button class="btn btn-secondary" id="refresh-form">
        <i class="fas fa-sync"></i> Load into Form
      </button>
    </div>

    <!-- Validation Tab -->
    <div
      class="tab-pane fade"
      id="validate-section"
      role="tabpanel"
      aria-labelledby="validate-tab"
    >
      <button class="btn btn-info mb-3" id="validate-btn">
        <i class="fas fa-check-circle"></i> Validate
      </button>
      <div id="validation-results" class="error-list"></div>
    </div>
  </div>

  <script>
    let schema;
    let formData = {};
    let ajv;
    let validate; // The compiled AJV validator

    /**
     * Collapses or expands a schema fieldset on clicking the heading
     */
    function toggleSection(event) {
      const icon = event.currentTarget.querySelector(".toggle-icon");
      icon.classList.toggle("collapsed");
      const sectionBody = event.currentTarget.nextElementSibling;
      if (sectionBody.style.display === "none") {
        sectionBody.style.display = "block";
      } else {
        sectionBody.style.display = "none";
      }
    }

    /**
     * As we build the UI, store references in `formData`.
     * We'll do a multi-level approach to handle nested objects.
     */
    function buildForm(schemaDef, root, path = "") {
      if (!schemaDef || !schemaDef.properties) {
        console.warn("Invalid schema portion for path:", path);
        return;
      }

      Object.entries(schemaDef.properties).forEach(([key, val]) => {
        const fullPath = path ? path + "." + key : key;
        createFieldOrSection(key, val, root, fullPath);
      });
    }

    /**
     * Renders either an expandable sub-section (if type=object) or an input field otherwise.
     */
    function createFieldOrSection(fieldName, fieldDef, container, fullPath) {
      const fieldWrapper = document.createElement("div");
      fieldWrapper.className = "schema-section mb-3";

      // If it's an object with properties, create a collapsible panel
      if (fieldDef.type === "object" && fieldDef.properties) {
        const heading = document.createElement("h4");
        heading.className = "d-flex justify-content-between align-items-center";
        heading.textContent = fieldDef.title || fieldName;
        const icon = document.createElement("span");
        icon.innerHTML = '<i class="fas fa-angle-down toggle-icon"></i>';
        heading.appendChild(icon);
        heading.onclick = toggleSection;

        const subSection = document.createElement("div");
        subSection.style.display = "block"; // default expanded

        fieldWrapper.appendChild(heading);
        fieldWrapper.appendChild(subSection);

        // Build the sub-section
        buildForm(fieldDef, subSection, fullPath);
      } else if (fieldDef.type === "object" && fieldDef.allOf) {
        // Handle "allOf" etc. in a simplified manner
        const heading = document.createElement("h4");
        heading.textContent = fieldDef.title || fieldName;
        fieldWrapper.appendChild(heading);
        // For brevity, we will skip advanced combos but do partial usage
        const subSection = document.createElement("div");
        fieldWrapper.appendChild(subSection);
        console.warn("Detected 'allOf' - not fully implemented for this example.");
      } else if (fieldDef.type === "array" && fieldDef.items) {
        const heading = document.createElement("h4");
        heading.textContent = fieldDef.title || fieldName;
        fieldWrapper.appendChild(heading);

        const desc = document.createElement("div");
        desc.className = "small-desc";
        desc.innerText = fieldDef.description || "";
        fieldWrapper.appendChild(desc);

        // For arrays, let's have a simple text to store JSON array, or a button to add items
        const textarea = document.createElement("textarea");
        textarea.className = "form-control";
        textarea.rows = 3;
        textarea.placeholder = "Enter array JSON here";

        // Load any default if available
        if (fieldDef.default !== undefined) {
          textarea.value = JSON.stringify(fieldDef.default, null, 2);
          setValueByPath(fullPath, fieldDef.default);
        }

        textarea.addEventListener("change", () => {
          try {
            const arr = JSON.parse(textarea.value);
            setValueByPath(fullPath, arr);
          } catch (error) {
            console.warn("Invalid JSON array input");
          }
        });

        fieldWrapper.appendChild(textarea);
      } else {
        // Base case: single input or boolean
        const label = document.createElement("label");
        label.className = "form-label fw-semibold";
        label.textContent = fieldDef.title || fieldName;
        if (fieldDef.description) {
          const descEl = document.createElement("div");
          descEl.className = "small-desc";
          descEl.textContent = fieldDef.description;
          label.appendChild(document.createElement("br"));
          label.appendChild(descEl);
        }

        const input = document.createElement("input");
        input.className = "form-control";

        if (fieldDef.type === "number" || fieldDef.type === "integer") {
          input.type = "number";
          if (fieldDef.minimum !== undefined) {
            input.min = fieldDef.minimum;
          }
          if (fieldDef.maximum !== undefined) {
            input.max = fieldDef.maximum;
          }
          input.step = "any";
        } else if (fieldDef.type === "boolean") {
          // Switch to a checkbox
          input.type = "checkbox";
          input.className = "form-check-input";
          label.className = "form-check-label fw-semibold";
          fieldWrapper.className = "form-check schema-section mb-3";
        } else {
          input.type = "text";
        }

        // default
        if (fieldDef.default !== undefined) {
          if (fieldDef.type === "boolean") {
            input.checked = fieldDef.default;
            setValueByPath(fullPath, !!fieldDef.default);
          } else {
            input.value = fieldDef.default;
            setValueByPath(fullPath, fieldDef.default);
          }
        }

        // add event
        if (fieldDef.type === "boolean") {
          input.addEventListener("change", () => {
            setValueByPath(fullPath, input.checked);
          });
        } else if (
          fieldDef.type === "number" ||
          fieldDef.type === "integer"
        ) {
          input.addEventListener("input", () => {
            setValueByPath(fullPath, input.value === "" ? null : Number(input.value));
          });
        } else {
          input.addEventListener("input", () => {
            setValueByPath(fullPath, input.value);
          });
        }

        // wrap
        fieldWrapper.appendChild(label);
        fieldWrapper.appendChild(input);
      }

      container.appendChild(fieldWrapper);
    }

    /**
     * Utility to set a value in formData for nested paths
     */
    function setValueByPath(path, value) {
      const parts = path.split(".");
      let current = formData;
      for (let i = 0; i < parts.length - 1; i++) {
        if (!current[parts[i]]) {
          current[parts[i]] = {};
        }
        current = current[parts[i]];
      }
      current[parts[parts.length - 1]] = value;
    }

    function getValueByPath(path) {
      const parts = path.split(".");
      let current = formData;
      for (let i = 0; i < parts.length; i++) {
        if (!current) return undefined;
        current = current[parts[i]];
      }
      return current;
    }

    /**
     * Build the top-level form from the loaded schema
     */
    function buildTopLevelForm() {
      const formContainer = document.getElementById("form-container");
      formContainer.innerHTML = "";

      // We expect schema.properties to exist
      if (!schema || !schema.properties) {
        console.error("No top-level properties in schema. Possibly not loaded yet.");
        return;
      }

      // Build top-level
      buildForm(schema, formContainer, "");
    }

    /**
     * After building, we can compile the AJV validator
     */
    function compileValidator() {
      ajv = new Ajv({ allErrors: true, strict: false });
      validate = ajv.compile(schema);
    }

    /**
     * Validate formData and display results
     */
    function validateFormData() {
      if (!validate) return;
      const valid = validate(formData);
      const resultsEl = document.getElementById("validation-results");
      resultsEl.innerHTML = "";

      if (valid) {
        resultsEl.innerHTML = '<div class="text-success fw-bold">✅ Data is valid!</div>';
      } else {
        const errors = validate.errors || [];
        let errHTML = '<ul class="text-danger">';
        errors.forEach((err) => {
          const path = err.instancePath || "(root)";
          errHTML += `<li><strong>${path}</strong>: ${err.message}</li>`;
        });
        errHTML += "</ul>";
        resultsEl.innerHTML = `
          <div class="text-danger fw-bold">❌ Validation Errors:</div>
          ${errHTML}
        `;
      }
    }

    async function loadSchema() {
      try {
        const resp = await fetch("suews-config-schema.json");
        schema = await resp.json();
        buildTopLevelForm();
        compileValidator();
      } catch (err) {
        console.error("Could not load or parse schema:", err);
      }
    }

    /**
     * Export to JSON
     */
    function exportToJson() {
      const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(formData, null, 2));
      const dlAnchorElem = document.createElement("a");
      dlAnchorElem.setAttribute("href", dataStr);
      dlAnchorElem.setAttribute("download", "suews_config.json");
      dlAnchorElem.click();
    }

    /**
     * Import JSON
     */
    function importJson(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          formData = JSON.parse(e.target.result);
          reflectFormDataToUI();
        } catch (error) {
          alert("Invalid JSON file");
        }
      };
      reader.readAsText(file);
    }

    /**
     * Sync the form data into the raw JSON textarea
     */
    function updateJsonView() {
      const jsonView = document.getElementById("json-view");
      jsonView.value = JSON.stringify(formData, null, 2);
    }

    /**
     * Called after we’ve updated formData externally or loaded from file.
     * We’ll rebuild the entire form and reload the fields with the updated data.
     * This is a naive approach but simpler for demonstration.
     */
    function reflectFormDataToUI() {
      // Rebuild top-level form elements
      buildTopLevelForm();
      // Overwrite the form with current formData values
      reflectValues("", schema, document.getElementById("form-container"));
    }

    function reflectValues(path, schemaDef, container) {
      if (!schemaDef || !schemaDef.properties) return;

      let idx = 0;
      Array.from(container.children).forEach((child) => {
        if (!child.classList.contains("schema-section")) return;
        const childName = Object.keys(schemaDef.properties)[idx];
        const childDef = schemaDef.properties[childName];
        const currentPath = path ? path + "." + childName : childName;
        idx++;

        if (childDef.type === "object") {
          // Recur
          const subSection = child.querySelector("div");
          reflectValues(currentPath, childDef, subSection);
        } else if (childDef.type === "array") {
          const textarea = child.querySelector("textarea");
          const val = getValueByPath(currentPath);
          if (val !== undefined) {
            textarea.value = JSON.stringify(val, null, 2);
          }
        } else {
          // Single input
          const input = child.querySelector("input");
          const val = getValueByPath(currentPath);
          if (childDef.type === "boolean") {
            input.checked = !!val;
          } else if (childDef.type === "number" || childDef.type === "integer") {
            input.value = val === undefined || val === null ? "" : val;
          } else {
            input.value = val !== undefined ? val : "";
          }
        }
      });
    }

    // INITIAL
    document.addEventListener("DOMContentLoaded", () => {
      loadSchema();

      const exportBtn = document.getElementById("export-json");
      exportBtn.addEventListener("click", exportToJson);

      const importInput = document.getElementById("import-json");
      importInput.addEventListener("change", (evt) => {
        const file = evt.target.files[0];
        if (file) {
          importJson(file);
        }
      });

      const validateBtn = document.getElementById("validate-btn");
      validateBtn.addEventListener("click", () => {
        validateFormData();
      });

      // JSON tab
      const jsonView = document.getElementById("json-view");
      // Keep form in sync with JSON text
      jsonView.addEventListener("input", () => {
        try {
          const newObj = JSON.parse(jsonView.value);
          formData = newObj;
        } catch {
          // do nothing on partial typed JSON
        }
      });
      // Refresh button
      const refreshFormBtn = document.getElementById("refresh-form");
      refreshFormBtn.addEventListener("click", () => {
        // Overwrite the form from the text
        try {
          formData = JSON.parse(jsonView.value);
          reflectFormDataToUI();
        } catch {
          alert("Invalid JSON input. Could not parse.");
        }
      });

      // Switch tabs: each time user switches to JSON tab, update JSON text area
      document.getElementById("json-tab").addEventListener("show.bs.tab", () => {
        updateJsonView();
      });
    });
  </script>

  <!-- Bootstrap JS (for tabs) -->
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"
  ></script>
</body>
</html>