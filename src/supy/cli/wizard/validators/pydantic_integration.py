"""
Pydantic integration for configuration validation.
"""

from typing import Dict, Any, List, Optional, Tuple
from pathlib import Path
import yaml

from ....data_model import SUEWSConfig
from ....data_model.type import RefValue


class PydanticValidator:
    """Handles validation using SUEWS Pydantic models"""

    def __init__(self):
        self.config_model = SUEWSConfig

    def validate_complete_config(
        self, config_dict: Dict[str, Any]
    ) -> Tuple[bool, List[str]]:
        """
        Validate a complete configuration against SUEWSConfig model.

        Returns:
            Tuple of (is_valid, list_of_errors)
        """
        try:
            # Convert to proper structure with RefValue wrappers
            structured_config = self._structure_config(config_dict)

            # Validate using Pydantic
            config = SUEWSConfig(**structured_config)

            return True, []

        except Exception as e:
            # Parse validation errors
            errors = self._parse_validation_errors(e)
            return False, errors

    def _structure_config(self, wizard_config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Convert wizard configuration to SUEWSConfig structure.

        The wizard collects data in a simplified format, but SUEWSConfig
        expects a specific structure with RefValue wrappers.
        """
        # Start with basic structure
        config = {
            "name": wizard_config.get("site", {}).get("name", "SUEWS Configuration"),
            "description": wizard_config.get("site", {}).get(
                "description", "Generated by SUEWS Wizard"
            ),
            "model": {"control": {}, "physics": {}},
            "sites": [],
        }

        # Map simulation settings to model control
        if "simulation" in wizard_config:
            sim = wizard_config["simulation"]

            if "timestep" in sim:
                config["model"]["control"]["tstep"] = sim["timestep"]

            if "start_date" in sim:
                config["model"]["control"]["start_time"] = {
                    "value": sim["start_date"] + " 00:00"
                }

            if "end_date" in sim:
                config["model"]["control"]["end_time"] = {
                    "value": sim["end_date"] + " 23:00"
                }

        # Map forcing data
        if "forcing" in wizard_config:
            forcing = wizard_config["forcing"]
            if "file_path" in forcing:
                config["model"]["control"]["forcing_file"] = {
                    "value": forcing["file_path"]
                }

        # Set default physics methods if not specified
        config["model"]["physics"] = {
            "netradiationmethod": {"value": 3},  # NARP
            "emissionsmethod": {"value": 2},  # JÃ¤rvi et al. 2011
            "storageheatmethod": {"value": 1},  # OHM
            "ohmincqf": {"value": 1},  # Include QF in OHM
            "stabilitymethod": {"value": 2},  # MO theory
            "roughlenheatmethod": {"value": 2},  # Kawai et al. 2009
            "roughlenmommethod": {"value": 2},  # Variable
        }

        # Create site from wizard data
        site = {
            "name": wizard_config.get("site", {}).get("name", "Site1"),
            "gridiv": 1,
            "properties": {},
            "initial_states": {},
        }

        # Map site properties
        if "site" in wizard_config:
            site_data = wizard_config["site"]

            if "latitude" in site_data:
                site["properties"]["lat"] = {"value": site_data["latitude"]}

            if "longitude" in site_data:
                site["properties"]["lng"] = {"value": site_data["longitude"]}

            if "altitude" in site_data:
                site["properties"]["alt"] = {"value": site_data["altitude"]}

            if "timezone" in site_data:
                site["properties"]["timezone"] = site_data["timezone"]

        # Map surface fractions if available
        if "surface" in wizard_config and "fractions" in wizard_config["surface"]:
            fractions = wizard_config["surface"]["fractions"]

            # Initialize land_cover structure
            site["properties"]["land_cover"] = {}

            # Map wizard surface names to SUEWS surface names
            surface_mapping = {
                "paved": "paved",
                "buildings": "bldgs",
                "evergreen_tree": "evetr",
                "deciduous_tree": "dectr",
                "grass": "grass",
                "bare_soil": "bsoil",
                "water": "water",
            }

            for wizard_name, suews_name in surface_mapping.items():
                if wizard_name in fractions:
                    site["properties"]["land_cover"][suews_name] = {
                        "sfr": {"value": fractions[wizard_name]}
                    }

                    # Add default properties for each surface
                    self._add_default_surface_properties(
                        site["properties"]["land_cover"][suews_name],
                        suews_name,
                        wizard_config,
                    )

        # Add site to config
        config["sites"].append(site)

        return config

    def _add_default_surface_properties(
        self,
        surface_dict: Dict[str, Any],
        surface_type: str,
        wizard_config: Dict[str, Any],
    ):
        """Add default surface properties based on surface type"""

        # Check if we have surface-specific properties in wizard config
        surface_props = wizard_config.get("surface", {})

        # Albedo
        if "albedo" in surface_props and surface_type in surface_props["albedo"]:
            surface_dict["alb"] = {"value": surface_props["albedo"][surface_type]}
        else:
            # Default albedos
            default_albedos = {
                "paved": 0.12,
                "bldgs": 0.15,
                "evetr": 0.10,
                "dectr": 0.15,
                "grass": 0.20,
                "bsoil": 0.15,
                "water": 0.10,
            }
            surface_dict["alb"] = {"value": default_albedos.get(surface_type, 0.15)}

        # Emissivity
        if (
            "emissivity" in surface_props
            and surface_type in surface_props["emissivity"]
        ):
            surface_dict["emis"] = {"value": surface_props["emissivity"][surface_type]}
        else:
            # Default emissivities
            default_emissivities = {
                "paved": 0.95,
                "bldgs": 0.91,
                "evetr": 0.98,
                "dectr": 0.98,
                "grass": 0.95,
                "bsoil": 0.95,
                "water": 0.98,
            }
            surface_dict["emis"] = {
                "value": default_emissivities.get(surface_type, 0.95)
            }

        # Add required thermal layers for non-vegetation surfaces
        if surface_type in ["paved", "bldgs", "water"]:
            surface_dict["thermal_layers"] = [
                {
                    "thickness": {"value": 0.1},
                    "k": {"value": 1.0},
                    "cp": {"value": 2.0e6},
                }
            ]

    def _parse_validation_errors(self, error: Exception) -> List[str]:
        """Parse Pydantic validation errors into readable messages"""
        errors = []

        if hasattr(error, "errors"):
            for err in error.errors():
                loc = " -> ".join(str(x) for x in err["loc"])
                msg = err["msg"]
                errors.append(f"{loc}: {msg}")
        else:
            errors.append(str(error))

        return errors

    def get_field_info(self, field_path: str) -> Dict[str, Any]:
        """
        Get information about a specific field from the Pydantic model.

        Returns dict with:
        - description: Field description
        - type: Field type
        - default: Default value if any
        - constraints: Validation constraints
        """
        # This would need to introspect the Pydantic model
        # For now, return basic info
        field_info = {
            "site.latitude": {
                "description": "Site latitude in decimal degrees",
                "type": "float",
                "constraints": {"min": -90, "max": 90},
            },
            "site.longitude": {
                "description": "Site longitude in decimal degrees",
                "type": "float",
                "constraints": {"min": -180, "max": 180},
            },
            "simulation.timestep": {
                "description": "Model time step in seconds",
                "type": "int",
                "constraints": {"min": 1, "max": 3600},
            },
        }

        return field_info.get(field_path, {})
