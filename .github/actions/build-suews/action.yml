name: 'Build SUEWS Wheels'
description: 'Build SUEWS wheels with cibuildwheel (standard or UMEP variant)'

inputs:
  buildplat:
    description: 'Build platform (e.g., ubuntu-latest, macos-15-intel, windows-2025)'
    required: true
  buildplat_name:
    description: 'Platform name for wheel (e.g., manylinux, macosx, win)'
    required: true
  buildplat_arch:
    description: 'Architecture (e.g., x86_64, arm64, AMD64)'
    required: true
  python:
    description: 'Python version to build for (e.g., cp39, cp310)'
    required: true
  is_umep_variant:
    description: 'Whether this is a UMEP variant build (true/false)'
    required: true
    default: 'false'
  wheel_name_suffix:
    description: 'Suffix for wheel artifact name (e.g., "", "-umep")'
    required: false
    default: ''
  test_tier:
    description: 'Test tier: smoke, core, cfg, standard, or all'
    required: false
    default: 'standard'
  is_testpypi_build:
    description: 'Whether this is a TestPyPI build (adds notice to README)'
    required: false
    default: 'false'

runs:
  using: 'composite'
  steps:
    - name: Inject TestPyPI notice into README
      if: inputs.is_testpypi_build == 'true'
      shell: bash
      run: |
        # Add TestPyPI notice after the first heading in README.md
        # This notice only appears in TestPyPI releases, not production PyPI
        # Insert after line 3 (after "This is the SUEWS urban climate model repository.")
        head -n 3 README.md > README.tmp
        # Note: Using printf to avoid YAML parsing issues with '>' at line start
        printf '\n' >> README.tmp
        printf '**TestPyPI Release**: This is a development version published to [test.pypi.org](https://test.pypi.org/project/supy/).\n' >> README.tmp
        printf 'For installation instructions, see [Testing Development Versions](https://docs.suews.io/latest/installation.html#testing-development-versions) in the documentation.\n' >> README.tmp
        tail -n +4 README.md >> README.tmp
        mv README.tmp README.md
        echo "Added TestPyPI notice to README.md"
        head -15 README.md

    - name: Modify pyproject.toml for NumPy 1.x compatibility
      if: inputs.is_umep_variant == 'true'
      shell: bash
      run: |
        echo "Building UMEP variant with NumPy 1.x compatibility"

        # Runtime: Pin to NumPy 1.x (QGIS 3.40 LTR uses 1.26.4)
        # MUST run before build-time replacement to match the trailing comma
        sed -i.bak 's/"numpy>=2\.0",/"numpy>=1.22,<2.0",/g' pyproject.toml

        # Build-time: Use oldest-supported-numpy for binary compatibility
        # Runs second to replace the remaining occurrence (no trailing comma in build-requires)
        sed -i.bak 's/"numpy>=2\.0"/"oldest-supported-numpy"/g' pyproject.toml

        echo "Modified pyproject.toml for UMEP build:"
        git diff pyproject.toml || true

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: 3.12

    - name: Generate version file from git
      shell: bash
      env:
        BUILD_UMEP_VARIANT: ${{ inputs.is_umep_variant }}
      run: |
        # Generate version file on host (where git is available)
        # This file will be copied into the cibuildwheel container
        if [ "${{ inputs.is_umep_variant }}" = "true" ]; then
          echo "Generating version for UMEP variant (rc1 suffix)"
          export BUILD_UMEP_VARIANT=true
        fi
        python3 get_ver_git.py
        echo "Generated version: $(cat src/supy/_version_scm.py | grep __version__)"

    - name: Build wheels
      uses: pypa/cibuildwheel@v3.2
      env:
        IS_32_BIT: ${{ inputs.buildplat_arch == 'x86' }}
        BUILD_UMEP_VARIANT: ${{ inputs.is_umep_variant }}
        CIBW_BUILD: ${{ inputs.python }}-${{ inputs.buildplat_name }}*
        CIBW_ARCHS: ${{ inputs.buildplat_arch }}
        # CIBW_ENABLE: ${{ inputs.python == 'cp314' && 'cp314' || '' }}
        CIBW_ENVIRONMENT_PASS_LINUX: ${{ inputs.is_umep_variant == 'true' && 'RUNNER_OS BUILD_UMEP_VARIANT' || 'RUNNER_OS' }}
        # Use manylinux_2_28 for Python 3.13+ (newer dependencies require it), manylinux2014 for 3.9-3.12 (older Linux compatibility)
        CIBW_MANYLINUX_X86_64_IMAGE: ${{ (inputs.python == 'cp313' || inputs.python == 'cp314') && 'manylinux_2_28' || 'manylinux2014' }}
        CIBW_MANYLINUX_AARCH64_IMAGE: ${{ (inputs.python == 'cp313' || inputs.python == 'cp314') && 'manylinux_2_28' || 'manylinux2014' }}
        # Configure pip for all platforms - prefer binary wheels
        CIBW_ENVIRONMENT: >
          PIP_PREFER_BINARY=1
          ${{ inputs.is_umep_variant == 'true' && 'BUILD_UMEP_VARIANT=true' || '' }}
        # Platform-specific: Linux Fortran compiler settings
        CIBW_ENVIRONMENT_LINUX: >
          FCFLAGS="-fno-optimize-sibling-calls -ffree-line-length-none"
          F90=gfortran
        CIBW_BEFORE_ALL_LINUX: >
          pip install --upgrade pip setuptools wheel &&
          if [[ "${{ inputs.is_umep_variant }}" == "true" ]]; then
            echo "Installing oldest-supported-numpy for UMEP variant build" &&
            pip install oldest-supported-numpy;
          else
            echo "Installing numpy>=2.0 for standard build" &&
            pip install 'numpy>=2.0';
          fi &&
          if [[ "${{ inputs.python }}" == "cp313" ]] || [[ "${{ inputs.python }}" == "cp314" ]]; then
            echo "Installing numpy for Python ${{ inputs.python }} f90wrap build" &&
            pip install numpy;
          fi
        CIBW_BEFORE_ALL_MACOS: >
          brew install gfortran &&
          brew unlink gfortran &&
          brew link gfortran
        # Windows MSYS2/pacman setup with two workarounds:
        # 1. Core package updates (pacman, msys2-runtime) terminate bash.exe via taskkill - use Windows-level
        #    error suppression (|| ver >nul) since bash can't execute || true when forcibly killed
        # 2. Mirror timeouts cause "Operation too slow" errors - use --disable-download-timeout + retry
        CIBW_BEFORE_ALL_WINDOWS: >
          (C:\msys64\usr\bin\bash.exe -lc "pacman -Syu --noconfirm --disable-download-timeout" || ver >nul) &&
          C:\msys64\usr\bin\bash.exe -lc "pacman -Syu --noconfirm --disable-download-timeout" &&
          C:\msys64\usr\bin\bash.exe -lc "for i in 1 2 3; do pacman -S --needed --noconfirm --disable-download-timeout mingw-w64-ucrt-x86_64-gcc mingw-w64-ucrt-x86_64-gcc-fortran mingw-w64-ucrt-x86_64-binutils mingw-w64-ucrt-x86_64-make mingw-w64-ucrt-x86_64-openblas && break || { echo Retry $i/3 && sleep 15; }; done"
        # Platform-specific: Windows compiler and toolchain settings
        CIBW_ENVIRONMENT_WINDOWS: >
          PATH="C:\\msys64\\ucrt64\\bin;$PATH"
          CC=gcc
          CXX=g++
          FC=gfortran
          CFLAGS="-D__USE_MINGW_ANSI_STDIO=1 -mlong-double-64"
          CXXFLAGS="-D__USE_MINGW_ANSI_STDIO=1 -mlong-double-64"
          FCFLAGS="-fno-optimize-sibling-calls -ffree-line-length-none"
          LDFLAGS="-lucrt -static-libgcc -static-libgfortran -LC:/msys64/ucrt64/lib -lsetjmp_compat"
        CIBW_BEFORE_BUILD_WINDOWS: >
          echo Creating setjmp compatibility library... &&
          echo int _setjmpex(void* buf) { extern int __intrinsic_setjmpex(void*); return __intrinsic_setjmpex(buf); } > setjmp_compat.c &&
          C:\msys64\ucrt64\bin\gcc.exe -c setjmp_compat.c -o setjmp_compat.o &&
          C:\msys64\ucrt64\bin\ar.exe rcs libsetjmp_compat.a setjmp_compat.o &&
          echo Library created, checking contents: &&
          C:\msys64\ucrt64\bin\nm.exe libsetjmp_compat.a &&
          echo Copying to standard locations: &&
          copy libsetjmp_compat.a C:\msys64\ucrt64\lib\ &&
          copy libsetjmp_compat.a C:\msys64\ucrt64\x86_64-w64-mingw32\lib\ &&
          echo Verifying library locations: &&
          dir C:\msys64\ucrt64\lib\libsetjmp_compat.a &&
          dir C:\msys64\ucrt64\x86_64-w64-mingw32\lib\libsetjmp_compat.a &&
          where python &&
          where gcc &&
          gcc --version &&
          pip install delvewheel
        CIBW_REPAIR_WHEEL_COMMAND_WINDOWS: "delvewheel repair -w {dest_dir} {wheel}"
        CIBW_TEST_REQUIRES: ${{ inputs.is_umep_variant == 'true' && 'pytest "numpy<2.0"' || 'pytest' }}
        # Test tiers: choose subset based on path detection and trigger
        CIBW_TEST_COMMAND: >
          python -m pytest {project}/test -v --tb=short
          ${{ inputs.test_tier == 'smoke' && '-m smoke' ||
              inputs.test_tier == 'core' && '-m "smoke or core"' ||
              inputs.test_tier == 'cfg' && '-m "smoke or cfg"' ||
              inputs.test_tier == 'standard' && '-m "not slow"' ||
              '--durations=10' }}
        MACOSX_DEPLOYMENT_TARGET: '15.0'

    - name: Upload wheels
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.python }}-${{ inputs.buildplat_name }}-${{ inputs.buildplat_arch }}${{ inputs.wheel_name_suffix }}
        path: ./wheelhouse/*.whl
