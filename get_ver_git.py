#!/usr/bin/env python3
"""
Version generation script for SUEWS/SuPy using git tags.

VERSIONING SYSTEM:
==================
This script generates version numbers based on git tags and commit distance.

For nightly builds (tags ending in .dev):
  - Tag: 2025.8.17.dev
  - At tag: generates 2025.8.17.dev0
  - After 2 commits: generates 2025.8.17.dev2

For production releases:
  - Tag: 2025.1.0
  - At tag: generates 2025.1.0
  - After commits: generates 2025.1.0.dev5 (5 commits after)

For UMEP/QGIS compatible builds (rc1 suffix):
  - When BUILD_UMEP_VARIANT=true environment variable is set
  - Tag: 2025.1.0 generates 2025.1.0rc1
  - These are NumPy 1.x compatible builds for QGIS 3.40 LTR
  - rc1 is a pre-release tag, ensuring pip install gets the stable version by default
  - See .github/workflows/build-publish_to_pypi.yml for build configuration

CRITICAL FOR NIGHTLY BUILDS:
The GitHub Actions workflow MUST create the tag BEFORE building wheels.
This ensures the version number matches the intended date. Previously,
creating tags after builds caused version mismatches (e.g., Aug 16
builds using Aug 15 tag + commits = wrong version on TestPyPI).

USAGE:
Called by meson.build during the build process to set the package version.
"""

import subprocess
import re
import os


def get_version_from_git():
    try:
        # Get the most recent tag and the number of commits since that tag
        # Only match version tags (starting with digits)
        describe_output = (
            subprocess.check_output([
                "git",
                "describe",
                "--tags",
                "--long",
                "--match=[0-9]*",
            ])
            .strip()
            .decode("utf-8")
        )

        # Match against the pattern including optional 'dev' part
        match = re.match(
            r"^(v?\d+\.\d+\.\d+(?:\.\w+)?)-(\d+)-g([0-9a-f]+)$", describe_output
        )
        # print(match.groups())

        if match:
            base_version = match.group(1)
            distance = int(match.group(2))
            commit_hash = match.group(3)

            # Clean up version to be valid Python packaging version
            if base_version.startswith("v"):
                base_version = base_version[1:]

            has_dev_suffix = ".dev" in base_version

            # IMPORTANT: For nightly .dev tags, we ALWAYS append a number
            # This ensures consistent versioning on TestPyPI:
            #   - Tag 2025.8.17.dev becomes version 2025.8.17.dev0
            #   - This prevents version mismatches between git tags and PyPI
            if has_dev_suffix:
                # Extract base version without .dev suffix
                base_without_dev = base_version.rsplit(".dev", 1)[0]
                # Always append .devN where N is the commit count (0 for the tag itself)
                version = f"{base_without_dev}.dev{distance}"
            elif distance == 0:
                # For production tags without .dev, keep as-is
                version = base_version
            else:
                # For production tags with commits after, add .dev with commit count
                version = f"{base_version}.dev{distance}"
        else:
            raise ValueError(
                f"Output '{describe_output}' does not match the expected pattern."
            )

        # Check for UMEP build variant (NumPy 1.x compatible build)
        # This is set by CI workflow for QGIS/UMEP compatible releases
        if os.environ.get("BUILD_UMEP_VARIANT") == "true":
            if ".dev" in version:
                # For dev/nightly builds: increment dev number to avoid version collision
                # Standard: 2025.10.15.dev0 (NumPy 2.x)
                # UMEP:     2025.10.15.dev1 (NumPy 1.x)
                # This allows both to coexist on TestPyPI for testing
                base, dev_num = version.rsplit(".dev", 1)
                version = f"{base}.dev{int(dev_num) + 1}"
            else:
                # For production releases: use rc1 suffix
                # rc1 (pre-release) ensures pip install gets stable version by default
                version = version + "rc1"

        return version

    except subprocess.CalledProcessError:
        raise RuntimeError(
            "Git command failed. Make sure you're running this script in a Git repository."
        )
    except Exception as e:
        raise RuntimeError(
            f"An error occurred while retrieving the version from Git: {e}"
        )


def write_version_file(version_str):
    version_file = "src/supy/_version_scm.py"
    version_tuple = parse_version_tuple(version_str)

    content = f"""# file generated by `get_ver_git.py`
# don't change, don't track in version control
__version__ = version = '{version_str}'
__version_tuple__ = version_tuple = {version_tuple}
"""

    with open(version_file, "w") as file:
        file.write(content)

    # print(f"Generated {version_file} with version {version_str}")


def get_commit_info():
    """Get both short and full commit hashes."""
    try:
        commit_short = (
            subprocess.check_output(
                ["git", "rev-parse", "--short=7", "HEAD"], stderr=subprocess.DEVNULL
            )
            .decode("utf-8")
            .strip()
        )

        commit_full = (
            subprocess.check_output(
                ["git", "rev-parse", "HEAD"], stderr=subprocess.DEVNULL
            )
            .decode("utf-8")
            .strip()
        )

        return commit_short, commit_full
    except:
        return "unknown", "unknown"


def parse_version_tuple(version_str):
    parts = version_str.split(".")
    major, minor, patch = map(int, parts[:3])
    if "dev" in parts[-1]:
        dev_part = parts[-1]
    else:
        dev_part = None

    if dev_part:
        return (major, minor, patch, dev_part)
    else:
        return (major, minor, patch)


if __name__ == "__main__":
    version_str = get_version_from_git()
    write_version_file(version_str)
    print(get_version_from_git())
