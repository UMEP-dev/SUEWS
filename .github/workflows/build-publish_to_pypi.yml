name: Build and Publish Python wheels to PyPI and TestPyPI

# ============================================================================
# WORKFLOW OVERVIEW
# ============================================================================
# This workflow handles all Python package builds and deployments for SUEWS/SuPy.
#
# TRIGGERS:
# - Nightly: 2 AM UTC daily for development releases
# - Tags: Any tag push (for releases to PyPI/TestPyPI)
# - PR: On pull requests for validation (strict mode ensures up-to-date)
# - Merge queue: On merge_group events for queue validation
# - Manual: Via workflow_dispatch
# - Master push: SKIPPED (PR already validated, no deployment needed)
#
# DEPLOYMENT STRATEGY:
# 1. VALIDATION ONLY (no deployment):
#    - Pull requests (draft): Minimal matrix (manylinux only, bookend Python 3.9 + 3.14)
#    - Pull requests (ready): Reduced matrix (ARM Mac + Linux + Windows, Python 3.9 + 3.14)
#    - Manual workflow_dispatch: Full matrix (all platforms + Python 3.9-3.14)
#
# 2. DEVELOPMENT RELEASES (TestPyPI only):
#    - Nightly cron (2 AM UTC, master branch only): Creates YYYY.M.D.dev tag → TestPyPI
#    - Builds TWO versions: standard (YYYY.M.D.dev0) + UMEP (YYYY.M.D.dev1)
#    - Both deployed to TestPyPI for comprehensive nightly testing
#    Installation:
#      Latest dev (NumPy 2.x): pip install -i https://test.pypi.org/simple/ supy
#      UMEP variant (NumPy 1.x): pip install -i https://test.pypi.org/simple/ supy==YYYY.M.D.dev1
#
# 3. PRODUCTION RELEASES (PyPI only):
#    - Tags without 'dev': Deploy to PyPI
#    Installation: pip install supy
#
# ============================================================================
# VERSIONING SYSTEM FOR NIGHTLY BUILDS
# ============================================================================
# Tag Format: YYYY.M.D.dev (e.g., 2025.8.17.dev)
# Published Version: YYYY.M.D.devN where N is commit count since tag
#   - At tag: 2025.8.17.dev0
#   - After 2 commits: 2025.8.17.dev2
#
# CRITICAL: Tag MUST be created BEFORE building wheels to ensure version consistency.
# Previously, creating tags after builds caused version mismatches where Aug 16 builds
# would use Aug 15 tag + commits, resulting in wrong version numbers on TestPyPI.
#
# WORKFLOW ORDER (for nightly builds):
# 1. create_nightly_tag: Creates today's tag (e.g., 2025.8.17.dev)
# 2. build_wheels: Builds using the new tag (produces 2025.8.17.dev0)
# 3. deploy_testpypi: Publishes correct version to TestPyPI
#
# RESILIENCE FEATURES:
# - Tags created even if some platform builds fail (maintains consecutive dates)
# - TestPyPI deployment proceeds with available wheels
# - Prevents gaps in nightly build sequence
#
# BUILD MATRIX STRATEGY:
# - Draft PR: Minimal (manylinux only, Python 3.9 + 3.14) for fastest feedback
# - Ready PR: Reduced (ARM Mac + Linux + Windows, Python 3.9 + 3.14) for speed with coverage
# - Tags/Nightly/Manual: Full (all platforms including x86_64 Mac, Python 3.9-3.14) for releases
# - UMEP builds: Python 3.12 only on all platforms (aligned with QGIS 3.40 LTR)
#
# ============================================================================
# UMEP/QGIS COMPATIBILITY BUILDS (rc1 pre-release versions)
# ============================================================================
# Every formal release tag automatically creates TWO PyPI versions:
#
# 1. STANDARD BUILD (build_wheels job):
#    - Tag: v2024.10.7
#    - Version: 2024.10.7
#    - NumPy: >=2.0 (build and runtime)
#    - Target: Standalone Python users
#    - Public facing, documented
#    - pip install supy → gets this version
#
# 2. UMEP BUILD (build_umep job):
#    - Tag: v2024.10.7 (same tag)
#    - Version: 2024.10.7rc1
#    - NumPy: oldest-supported-numpy (build), >=1.22,<2.0 (runtime)
#    - Target: QGIS 3.40 LTR (NumPy 1.26.4) / UMEP plugin users
#    - Undocumented publicly, for UMEP requirements files only
#    - Pre-release tag (rc1) ensures pip skips it by default
#
# 3. QGIS COMPATIBILITY TESTING (test_qgis job - GH-1035):
#    - Runs AFTER build_umep completes
#    - Downloads the ACTUAL UMEP wheel (not source build)
#    - Installs in OSGeo4W/QGIS environment (Windows)
#    - Tests Qt signal handler compatibility (f90wrap fix)
#    - Validates errors don't crash Qt applications
#
# AUTOMATIC DUAL BUILD PROCESS:
# - Jobs run in parallel for efficiency
# - BUILD_UMEP_VARIANT env var triggers rc1 suffix in get_ver_git.py
# - pyproject.toml modified for NumPy 1.x at build time
# - Both wheel sets deployed to PyPI together (production tags only)
# - UMEP builds use Python 3.12 only (aligned with QGIS 3.40 LTR bundled Python)
# - UMEP build triggers (runs on ALL events for continuous NumPy 1.x testing):
#   * PRs: win cp312 (NumPy 1.x validation before merge, Windows = QGIS primary platform)
#   * Master/manual: win cp312 (continuous UMEP compatibility testing)
#   * Nightly/dev tags: win cp312 (daily testing, uses .dev1 to avoid version collision)
#   * Production tags: all platforms cp312 (complete distribution → PyPI, uses rc1 suffix)
#
# UMEP INTEGRATION:
# - Production: UMEP requirements specify supy==2024.10.7rc1
# - Nightly testing: UMEP developers can test with supy==2025.10.15.dev1
# - UMEP users install via UMEP requirements, never see version details
# - Versioning strategy (see get_ver_git.py):
#   * Production: X.Y.Zrc1 (pre-release for QGIS compatibility)
#   * Dev/nightly: X.Y.Z.dev1 (standard uses .dev0, UMEP uses .dev1)
# - No coordination needed - rc1 always exists for every production release
#
# VERSIONING:
# - rc1 is PEP 440 compliant pre-release version (release candidate 1)
# - Pre-releases are skipped by default: pip install supy → 2024.10.7 (not rc1)
# - Indicates alternative build config (NumPy 1.x), not unstable software
# - See get_ver_git.py for version string logic
# ============================================================================

on:
  push:
    # Skip builds for regular master pushes - PR already validated code
    # Only build when deploying: tags trigger builds for PyPI/TestPyPI
    tags:
      - '*'  # Trigger on any tag push (no path filter - tags = releases, build everything)

  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
    # No path filters - workflow ALWAYS runs for branch protection
    # Path detection happens in detect-changes job (secure, inside workflow)

  merge_group:
    # Handle merge queue validation - required for merge queue to work
    types: [checks_requested]

  schedule:
    # Run nightly builds at 2 AM UTC
    - cron: '0 2 * * *'

  workflow_dispatch:
    inputs:
      qgis_test_only:
        description: 'Skip builds, test QGIS with TestPyPI wheel (fast iteration)'
        type: boolean
        default: false
      supy_version:
        description: 'Optional SuPy version for qgis_test_only (e.g., 2025.1.2.dev1)'
        type: string
        default: ''

# Cancel in-progress runs when new commits are pushed to the same PR/branch
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  # Create nightly tag BEFORE building to ensure correct version
  create_nightly_tag:
    name: Create nightly tag for scheduled builds
    runs-on: ubuntu-latest
    # Only run for scheduled (nightly) builds
    if: github.event_name == 'schedule'
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create and push nightly tag
        run: |
          set -e

          # Get the current date in YYYY.M.D format (without leading zeros as requested)
          YEAR=$(date -u +%Y)
          MONTH=$(date -u +%-m)  # Without leading zero
          DAY=$(date -u +%-d)    # Without leading zero

          # Create a dev tag for the nightly build
          DEV_TAG="${YEAR}.${MONTH}.${DAY}.dev"
          echo "Creating dev tag: ${DEV_TAG}"

          # Configure git
          git config user.name github-actions
          git config user.email github-actions@github.com

          # Check if tag already exists
          if git ls-remote --tags origin | grep -q "refs/tags/${DEV_TAG}"; then
            echo "Tag ${DEV_TAG} already exists on remote, skipping tag creation"
          else
            # Create and push the tag
            git tag -a "${DEV_TAG}" -m "Nightly build ${YEAR}-${MONTH}-${DAY}"
            git push origin "${DEV_TAG}"
            echo "Successfully created and pushed tag ${DEV_TAG}"
          fi

  # Detect if code changes require builds (PR branch protection security)
  detect-changes:
    name: Detect code changes
    runs-on: ubuntu-latest
    # Only run for pull requests and merge queue (push/tag/schedule always build)
    if: github.event_name == 'pull_request' || github.event_name == 'merge_group'
    outputs:
      needs-build: ${{ steps.filter.outputs.core == 'true' || steps.filter.outputs.util == 'true' || steps.filter.outputs.cfg == 'true' || steps.filter.outputs.tests == 'true' }}
      core-changed: ${{ steps.filter.outputs.core }}
      util-changed: ${{ steps.filter.outputs.util }}
      cfg-changed: ${{ steps.filter.outputs.cfg }}
      tests-changed: ${{ steps.filter.outputs.tests }}
      docs-changed: ${{ steps.filter.outputs.docs }}
      site-changed: ${{ steps.filter.outputs.site }}
    steps:
      - uses: actions/checkout@v4

      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            core:
              # Fortran physics
              - 'src/suews/src/**'
              # Fortran driver interface
              - 'src/supy_driver/**'
              - 'src/supy/supy_driver/**'
              # Core Python files that affect scientific rigour
              - 'src/supy/_run.py'
              - 'src/supy/_supy_module.py'
              - 'src/supy/_load.py'
              - 'src/supy/_post.py'
              - 'src/supy/_check.py'
              - 'src/supy/_save.py'
              - 'src/supy/suews_sim.py'
              # Catch-all for core package changes
              - 'src/suews/**'
            util:
              # Utility modules (nice-to-have)
              - 'src/supy/util/**'
              # Default category for remaining supy changes
              - 'src/supy/**'
            cfg:
              # Config validation
              - 'src/supy/data_model/**'
              # CLI commands
              - 'src/supy/cmd/**'
              # JSON configs
              - 'src/supy/*.json'
              # Build workflows and scripts (explicit, not .github/**)
              - '.github/workflows/build-publish_to_pypi.yml'
              - '.github/workflows/cibuildwheel-debug.yml'
              - '.github/scripts/**'
              # Build system files
              - 'pyproject.toml'
              - 'meson.build'
              - 'meson_options.txt'
              - 'Makefile'
              - 'get_ver_git.py'
              - 'scripts/**'
            site:
              # Static site content (GitHub Pages) - separate from wheel builds
              - 'site/**'
            tests:
              - 'test/**'
            docs:
              # Documentation source files
              - 'docs/**'
              # Data models that generate RST
              - 'src/supy/data_model/**'
              # RTD configuration
              - '.readthedocs.yml'
              # Version detection used by docs
              - 'get_ver_git.py'
              # Dependencies that affect doc builds
              - 'pyproject.toml'

  # Determine if we should run limited or full matrix
  determine_matrix:
    name: Determine build matrix
    runs-on: ubuntu-latest
    needs: [detect-changes]
    # Always run - detect-changes is skipped for non-PR events, but we still need matrix
    if: always() && (needs.detect-changes.result == 'success' || needs.detect-changes.result == 'skipped')
    outputs:
      buildplat: ${{ steps.set-matrix.outputs.buildplat }}
      python: ${{ steps.set-matrix.outputs.python }}
      umep_buildplat: ${{ steps.set-matrix.outputs.umep_buildplat }}
      umep_python: ${{ steps.set-matrix.outputs.umep_python }}
      test_tier: ${{ steps.set-matrix.outputs.test_tier }}
    steps:
      - name: Set matrix based on trigger type
        id: set-matrix
        run: |
          # Platform matrix
          FULL_PLATFORMS='[["ubuntu-latest", "manylinux", "x86_64"], ["macos-15-intel", "macosx", "x86_64"], ["macos-latest", "macosx", "arm64"], ["windows-2025", "win", "AMD64"]]'
          PR_PLATFORMS='[["ubuntu-latest", "manylinux", "x86_64"], ["macos-latest", "macosx", "arm64"], ["windows-2025", "win", "AMD64"]]'
          MINIMAL_PLATFORMS='[["ubuntu-latest", "manylinux", "x86_64"]]'

          CORE_CHANGED="${{ needs.detect-changes.outputs.core-changed || 'false' }}"
          UTIL_CHANGED="${{ needs.detect-changes.outputs.util-changed || 'false' }}"
          CFG_CHANGED="${{ needs.detect-changes.outputs.cfg-changed || 'false' }}"
          TESTS_CHANGED="${{ needs.detect-changes.outputs.tests-changed || 'false' }}"

          # Python version strategies:
          # - Draft PR: minimal (1 platform, bookend versions) for fastest feedback
          # - PR/Master: reduced (ARM Mac + Linux + Windows, bookend versions) for speed with good coverage
          # - Tags/Schedule/Manual: full (all platforms including x86_64 Mac, all Python versions) for comprehensive testing

          if [[ "${{ github.event_name }}" == "pull_request" ]] && [[ "${{ github.event.pull_request.draft }}" == "true" ]]; then
            if [[ "$CORE_CHANGED" == "true" ]]; then
              echo "Draft PR with core changes - reduced platforms, core tests"
              echo "buildplat=$PR_PLATFORMS" >> $GITHUB_OUTPUT
              echo 'python=["cp39", "cp314"]' >> $GITHUB_OUTPUT
              echo "test_tier=core" >> $GITHUB_OUTPUT
            elif [[ "$CFG_CHANGED" == "true" ]]; then
              echo "Draft PR with cfg changes - reduced platforms, cfg tests"
              echo "buildplat=$PR_PLATFORMS" >> $GITHUB_OUTPUT
              echo 'python=["cp39", "cp314"]' >> $GITHUB_OUTPUT
              echo "test_tier=cfg" >> $GITHUB_OUTPUT
            else
              echo "Draft PR with util/tests changes - minimal platform, smoke tests"
              echo "buildplat=$MINIMAL_PLATFORMS" >> $GITHUB_OUTPUT
              echo 'python=["cp39", "cp314"]' >> $GITHUB_OUTPUT
              echo "test_tier=smoke" >> $GITHUB_OUTPUT
            fi
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            if [[ "$CORE_CHANGED" == "true" ]]; then
              echo "Ready PR with core changes - reduced platforms, standard tests"
              echo "buildplat=$PR_PLATFORMS" >> $GITHUB_OUTPUT
              echo 'python=["cp39", "cp314"]' >> $GITHUB_OUTPUT
              echo "test_tier=standard" >> $GITHUB_OUTPUT
            elif [[ "$CFG_CHANGED" == "true" ]]; then
              echo "Ready PR with cfg changes - reduced platforms, standard tests"
              echo "buildplat=$PR_PLATFORMS" >> $GITHUB_OUTPUT
              echo 'python=["cp39", "cp314"]' >> $GITHUB_OUTPUT
              echo "test_tier=standard" >> $GITHUB_OUTPUT
            else
              echo "Ready PR with util/tests changes - reduced platforms, smoke tests"
              echo "buildplat=$PR_PLATFORMS" >> $GITHUB_OUTPUT
              echo 'python=["cp39", "cp314"]' >> $GITHUB_OUTPUT
              echo "test_tier=smoke" >> $GITHUB_OUTPUT
            fi
          elif [[ "${{ github.event_name }}" == "merge_group" ]]; then
            echo "Running reduced matrix for merge queue validation"
            echo "buildplat=$PR_PLATFORMS" >> $GITHUB_OUTPUT
            echo 'python=["cp39", "cp314"]' >> $GITHUB_OUTPUT
            echo "test_tier=standard" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "schedule" ]]; then
            echo "Running full matrix for nightly (all platforms, all Python versions, all tests)"
            echo "buildplat=$FULL_PLATFORMS" >> $GITHUB_OUTPUT
            echo 'python=["cp39", "cp310", "cp311", "cp312", "cp313", "cp314"]' >> $GITHUB_OUTPUT
            echo "test_tier=all" >> $GITHUB_OUTPUT
          else
            echo "Running full matrix for tags/manual (all platforms, all Python versions, all tests)"
            echo "buildplat=$FULL_PLATFORMS" >> $GITHUB_OUTPUT
            echo 'python=["cp39", "cp310", "cp311", "cp312", "cp313", "cp314"]' >> $GITHUB_OUTPUT
            echo "test_tier=all" >> $GITHUB_OUTPUT
          fi

          # UMEP builds: Python 3.12 only (aligned with QGIS 3.40 LTR bundled Python)
          # PR/nightly: Windows only (QGIS primary platform) for quick validation
          # Production: all platforms for complete UMEP distribution
          echo "UMEP matrix: cp312 only (QGIS 3.40 LTR uses Python 3.12)"
          echo 'umep_buildplat=[["windows-2025", "win", "AMD64"]]' >> $GITHUB_OUTPUT
          echo 'umep_python=["cp312"]' >> $GITHUB_OUTPUT

  build_wheels:
    name: Build wheel for ${{ matrix.python }}-${{ matrix.buildplat[1] }} ${{ matrix.buildplat[2] }}
    runs-on: ${{ matrix.buildplat[0] }}
    needs: [determine_matrix, create_nightly_tag, detect-changes]
    # Run if:
    # 1. Not a PR (push/tag/schedule always build), OR
    # 2. PR with code changes (detect-changes.outputs.needs-build == 'true')
    # 3. AND other dependencies succeeded/skipped
    # 4. AND not in qgis_test_only mode (fast iteration skips builds)
    if: |
      always() &&
      inputs.qgis_test_only != true &&
      needs.determine_matrix.result == 'success' &&
      (needs.create_nightly_tag.result == 'success' || needs.create_nightly_tag.result == 'skipped') &&
      (needs.detect-changes.result == 'skipped' || needs.detect-changes.outputs.needs-build == 'true')
    strategy:
      matrix:
        buildplat: ${{ fromJson(needs.determine_matrix.outputs.buildplat) }}
        python: ${{ fromJson(needs.determine_matrix.outputs.python) }}

      fail-fast: false

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Build SUEWS wheels (standard variant)
        uses: ./.github/actions/build-suews
        with:
          buildplat: ${{ matrix.buildplat[0] }}
          buildplat_name: ${{ matrix.buildplat[1] }}
          buildplat_arch: ${{ matrix.buildplat[2] }}
          python: ${{ matrix.python }}
          is_umep_variant: 'false'
          wheel_name_suffix: ''
          test_tier: ${{ needs.determine_matrix.outputs.test_tier }}
          is_testpypi_build: ${{ github.event_name == 'schedule' || (startsWith(github.ref, 'refs/tags/') && contains(github.ref, 'dev')) }}

  build_umep:
    name: Build UMEP wheel (rc1/dev1) for ${{ matrix.python }}-${{ matrix.buildplat[1] }} ${{ matrix.buildplat[2] }}
    runs-on: ${{ matrix.buildplat[0] }}
    needs: [determine_matrix, create_nightly_tag, detect-changes]
    # Run if:
    # 1. Not a PR (push/tag/schedule always build), OR
    # 2. PR with code changes (detect-changes.outputs.needs-build == 'true')
    # 3. AND other dependencies succeeded/skipped
    # 4. AND not in qgis_test_only mode (fast iteration skips builds)
    # UMEP versioning:
    #   - Production tags: X.Y.Zrc1 (pre-release for QGIS)
    #   - Dev/nightly: X.Y.Z.dev1 (incremented to avoid collision with standard .dev0)
    if: |
      always() &&
      inputs.qgis_test_only != true &&
      needs.determine_matrix.result == 'success' &&
      (needs.create_nightly_tag.result == 'success' || needs.create_nightly_tag.result == 'skipped') &&
      (needs.detect-changes.result == 'skipped' || needs.detect-changes.outputs.needs-build == 'true')
    strategy:
      matrix:
        # Limited matrix (manylinux cp312) for PRs/master/nightly/manual
        # Full matrix (all platforms cp312) for production tags only
        # IMPORTANT: Always use cp312 only for UMEP (QGIS 3.40 LTR compatibility)
        buildplat: ${{ (startsWith(github.ref, 'refs/tags/') && !contains(github.ref, 'dev')) && fromJson(needs.determine_matrix.outputs.buildplat) || fromJson(needs.determine_matrix.outputs.umep_buildplat) }}
        python: ${{ fromJson(needs.determine_matrix.outputs.umep_python) }}

      fail-fast: false

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Build SUEWS wheels (UMEP variant)
        uses: ./.github/actions/build-suews
        with:
          buildplat: ${{ matrix.buildplat[0] }}
          buildplat_name: ${{ matrix.buildplat[1] }}
          buildplat_arch: ${{ matrix.buildplat[2] }}
          python: ${{ matrix.python }}
          is_umep_variant: 'true'
          wheel_name_suffix: '-umep'
          test_tier: ${{ needs.determine_matrix.outputs.test_tier }}
          is_testpypi_build: ${{ github.event_name == 'schedule' || (startsWith(github.ref, 'refs/tags/') && contains(github.ref, 'dev')) }}

  # NOTE: Documentation preview deployment moved to pages-deploy.yml
  # This consolidates all GitHub Pages content (site, schemas, docs) in one workflow

  # ============================================================================
  # QGIS/Qt COMPATIBILITY TESTING (GH-1035)
  # ============================================================================
  # Tests that UMEP wheels work correctly in QGIS/OSGeo4W environment.
  # This validates the f90wrap signal handler fix prevents Qt crashes.
  #
  # Runs after build_umep to test the ACTUAL wheels that get deployed,
  # not a source build (which might have different NumPy/Qt behaviour).
  # ============================================================================
  test_qgis:
    name: Test UMEP wheel in QGIS/OSGeo4W
    runs-on: windows-latest
    timeout-minutes: 30
    needs: [build_umep, detect-changes]
    # Run when:
    # 1. UMEP build succeeds (normal mode), OR
    # 2. qgis_test_only mode (skip builds, use TestPyPI wheel for fast iteration)
    if: |
      always() &&
      (needs.build_umep.result == 'success' || inputs.qgis_test_only == true)

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download UMEP wheel artifact
        if: inputs.qgis_test_only != true
        uses: actions/download-artifact@v4
        with:
          # Download Windows cp312 UMEP wheel
          name: cp312-win-AMD64-umep
          path: ./wheels/

      - name: List downloaded wheels
        if: inputs.qgis_test_only != true
        shell: pwsh
        run: |
          Write-Host "Downloaded UMEP wheels:"
          Get-ChildItem -Path ./wheels/ -Recurse

      - name: Install OSGeo4W (QGIS)
        shell: pwsh
        run: |
          # Download OSGeo4W installer
          # Reference: https://trac.osgeo.org/osgeo4w/wiki/CommandLine
          $installerUrl = "https://download.osgeo.org/osgeo4w/v2/osgeo4w-setup.exe"
          $installerPath = "$env:TEMP\osgeo4w-setup.exe"
          Invoke-WebRequest -Uri $installerUrl -OutFile $installerPath

          # Install QGIS LTR with Python packages
          # --quiet-mode: Unattended install
          # --autoaccept: Accept all licenses
          # --no-desktop: Skip desktop shortcuts
          # --arch x86_64: 64-bit installation
          # Packages: qgis-ltr (QGIS Long Term Release with Python/Qt)
          $args = @(
            "--root", "C:\OSGeo4W",
            "--site", "https://download.osgeo.org/osgeo4w/v2",
            "--quiet-mode",
            "--autoaccept",
            "--no-desktop",
            "--arch", "x86_64",
            "--packages", "qgis-ltr"
          )
          Write-Host "Installing OSGeo4W with args: $args"
          Start-Process -FilePath $installerPath -ArgumentList $args -Wait -NoNewWindow

          # Verify installation
          Write-Host "OSGeo4W installation complete"
          if (Test-Path "C:\OSGeo4W\bin\o4w_env.bat") {
            Write-Host "OSGeo4W environment script found"
          } else {
            Write-Error "OSGeo4W installation failed - o4w_env.bat not found"
            exit 1
          }

      - name: Configure OSGeo4W environment
        shell: cmd
        run: |
          :: Initialize OSGeo4W environment
          call C:\OSGeo4W\bin\o4w_env.bat

          :: Verify Python version
          python --version
          python -c "import sys; print(sys.executable)"

          :: Check Qt availability
          python -c "from PyQt5.QtCore import QCoreApplication; print('PyQt5 available')"

          :: Check NumPy version (should be 1.x in QGIS)
          python -c "import numpy; print(f'NumPy version: {numpy.__version__}')"

      - name: Install UMEP wheel in OSGeo4W (from artifact)
        if: inputs.qgis_test_only != true
        shell: cmd
        run: |
          call C:\OSGeo4W\bin\o4w_env.bat

          :: Bootstrap pip (OSGeo4W Python doesn't include pip by default)
          python -m ensurepip --upgrade

          :: Find and install the wheel
          for %%f in (wheels\*.whl) do (
            echo Installing wheel: %%f
            python -m pip install "%%f"
          )

          :: Verify installation
          python -c "import supy; print(f'supy version: {supy.__version__}')"

      - name: Install UMEP wheel in OSGeo4W (from TestPyPI - fast mode)
        id: install_umep_fast
        if: inputs.qgis_test_only == true
        shell: cmd
        run: |
          call C:\OSGeo4W\bin\o4w_env.bat

          :: Bootstrap pip (OSGeo4W Python doesn't include pip by default)
          python -m ensurepip --upgrade

          :: Install requested version (if provided) or latest pre-release from TestPyPI
          :: Uses --pre to get pre-release versions
          :: UMEP wheel has numpy>=1.22,<2.0 baked into metadata (see build action)
          set "SUPY_VERSION_INPUT=${{ inputs.supy_version }}"
          if "%SUPY_VERSION_INPUT%"=="" (
            set "SUPY_VERSION_PROVIDED=false"
            echo Installing latest pre-release from TestPyPI...
            python -m pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ --pre supy
          ) else (
            set "SUPY_VERSION_PROVIDED=true"
            echo Installing supy==%SUPY_VERSION_INPUT% from TestPyPI...
            python -m pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ "supy==%SUPY_VERSION_INPUT%"
          )

          :: Verify installation and decide whether to run QGIS test
          python -c "import os, re, supy, sys; v=supy.__version__; print(f'supy version: {v}'); ok=bool(re.search(r'(rc1|\.dev1)', v)); open(os.environ['GITHUB_OUTPUT'],'a').write(f'qgis_test_ready={str(ok).lower()}\\n'); provided=os.environ.get('SUPY_VERSION_PROVIDED','false').lower()=='true'; (not ok and provided) and (print('ERROR: supy version is not an UMEP variant (rc1 or .dev1).') or sys.exit(1)); (not ok and not provided) and print('SKIP: UMEP variant not found on TestPyPI; skipping QGIS test. Provide supy_version input or publish a dev1/rc1 wheel.')"

      - name: Inspect STOP intercept symbols in .pyd (GH-1035)
        if: inputs.qgis_test_only != true || steps.install_umep_fast.outputs.qgis_test_ready == 'true'
        shell: cmd
        run: |
          :: Set up OSGeo4W environment
          call C:\OSGeo4W\bin\o4w_env.bat

          :: Find the _supy_driver extension
          echo === Locating _supy_driver extension ===
          for /f "delims=" %%p in ('python -c "import supy._supy_driver as d; print(d.__file__)"') do set PYD_PATH=%%p
          echo Extension path: %PYD_PATH%

          :: Check file size
          for %%f in ("%PYD_PATH%") do echo Extension size: %%~zf bytes

          :: Try to inspect symbols with dumpbin (Visual Studio) or nm (MinGW)
          echo.
          echo === STOP Intercept Symbols ===
          echo Checking for gfortran STOP handlers...

          :: Use findstr to check for symbols in the binary
          :: Note: dumpbin may not be available; use strings-like approach
          python -c "import supy._supy_driver as d; f=open(d.__file__,'rb'); data=f.read(); f.close(); syms=['suews_stop_string','suews_stop_numeric','_gfortran_stop_string','_gfortran_stop_numeric','f90wrap_abort_']; [print(f'  {s}: {\"FOUND\" if s.encode() in data else \"not found\"}') for s in syms]"

          :: Run the dedicated test script (cross-platform, moved from test/umep/)
          echo.
          echo === Running STOP interception test ===
          python test\core\test_build_symbols.py

      - name: Run PyQGIS error handling test
        if: inputs.qgis_test_only != true || steps.install_umep_fast.outputs.qgis_test_ready == 'true'
        shell: cmd
        run: |
          :: Set up OSGeo4W base environment
          call C:\OSGeo4W\bin\o4w_env.bat

          :: Configure QGIS Python environment (OSGeo4W v2 doesn't have qgis_env.bat)
          set QGIS_PREFIX_PATH=C:\OSGeo4W\apps\qgis-ltr
          set PYTHONPATH=%QGIS_PREFIX_PATH%\python;%PYTHONPATH%
          set PATH=%QGIS_PREFIX_PATH%\bin;%PATH%

          :: Set Qt to headless mode (must be before any Qt import)
          set QT_QPA_PLATFORM=offscreen

          :: Verify QGIS module is accessible
          python -c "from qgis.core import QgsApplication; print('QGIS Python bindings available')"

          :: Run test inside actual PyQGIS context (headless)
          :: Validates f90wrap signal handler fix (GH-1035)
          python test\umep\test_pyqgis_error_handling.py

  # PR gate: single consolidated check for branch protection
  # This job ALWAYS runs for PRs and merge queue and reports pass/fail based on build results
  pr-gate:
    name: PR build validation
    runs-on: ubuntu-latest
    # Only run for pull requests and merge queue, but ALWAYS run (even if builds skip)
    if: always() && (github.event_name == 'pull_request' || github.event_name == 'merge_group')
    needs: [build_wheels, build_umep, test_qgis, detect-changes]
    steps:
      - name: Check build results
        run: |
          echo "=== Job Results ==="
          echo "detect-changes: ${{ needs.detect-changes.result }}"
          echo "build_wheels: ${{ needs.build_wheels.result }}"
          echo "build_umep: ${{ needs.build_umep.result }}"
          echo "test_qgis: ${{ needs.test_qgis.result }}"
          echo "needs-build: ${{ needs.detect-changes.outputs.needs-build }}"
          echo ""

          # STEP 1: Verify detect-changes succeeded
          if [[ "${{ needs.detect-changes.result }}" != "success" ]]; then
            echo "FAIL: Path detection failed - cannot verify PR safety"
            echo "  detect-changes result: ${{ needs.detect-changes.result }}"
            exit 1
          fi

          # Track validation status
          VALIDATION_PASSED=true

          # Check if code changes require builds
          NEEDS_BUILD="${{ needs.detect-changes.outputs.needs-build }}"

          if [[ "$NEEDS_BUILD" == "true" ]]; then
            # Code changes detected - builds must run and pass
            echo "Code changes detected - validating builds..."

            if [[ "${{ needs.build_wheels.result }}" == "success" ]] && \
               [[ "${{ needs.build_umep.result }}" == "success" ]]; then
              echo "OK: Code builds passed"
            else
              echo "FAIL: Code builds failed or incomplete"
              echo "  build_wheels: ${{ needs.build_wheels.result }}"
              echo "  build_umep: ${{ needs.build_umep.result }}"
              VALIDATION_PASSED=false
            fi

            # Validate QGIS/Qt compatibility tests
            if [[ "${{ needs.test_qgis.result }}" == "success" ]]; then
              echo "OK: QGIS/Qt compatibility tests passed"
            elif [[ "${{ needs.test_qgis.result }}" == "skipped" ]]; then
              echo "WARN: QGIS tests skipped (UMEP build may have failed)"
            else
              echo "FAIL: QGIS/Qt compatibility tests failed"
              echo "  test_qgis: ${{ needs.test_qgis.result }}"
              VALIDATION_PASSED=false
            fi

          else
            # No code changes - builds should skip
            echo "No code changes - builds not required"

            if [[ "${{ needs.build_wheels.result }}" == "skipped" ]] && \
               [[ "${{ needs.build_umep.result }}" == "skipped" ]]; then
              echo "OK: Code builds correctly skipped"
            else
              echo "WARN: Unexpected: builds ran for non-code PR"
              echo "  build_wheels: ${{ needs.build_wheels.result }}"
              echo "  build_umep: ${{ needs.build_umep.result }}"
              # Still pass if builds succeeded (conservative)
              if [[ "${{ needs.build_wheels.result }}" != "success" ]] || \
                 [[ "${{ needs.build_umep.result }}" != "success" ]]; then
                if [[ "${{ needs.build_wheels.result }}" != "skipped" ]] || \
                   [[ "${{ needs.build_umep.result }}" != "skipped" ]]; then
                  VALIDATION_PASSED=false
                fi
              fi
            fi

            # QGIS tests should also be skipped when no code changes
            if [[ "${{ needs.test_qgis.result }}" == "skipped" ]]; then
              echo "OK: QGIS tests correctly skipped"
            elif [[ "${{ needs.test_qgis.result }}" == "success" ]]; then
              echo "OK: QGIS tests passed (ran unexpectedly but OK)"
            else
              echo "FAIL: QGIS tests failed"
              VALIDATION_PASSED=false
            fi
          fi

          # NOTE: Docs build validation moved to pages-deploy.yml

          # Final result
          echo ""
          if [[ "$VALIDATION_PASSED" == "true" ]]; then
            echo "OK: All validations passed"
            exit 0
          else
            echo "FAIL: Validation failed"
            exit 1
          fi

  deploy_testpypi:
    name: Publish to TestPyPI
    runs-on: ubuntu-latest
    needs:
      - determine_matrix
      - build_wheels
      - create_nightly_tag  # Will be skipped for non-nightly builds
    # Deploy to TestPyPI for nightly builds even if some platforms fail
    # This ensures continuous availability of development builds
    if: |
      always() &&
      needs.build_wheels.result != 'cancelled' &&
      (needs.create_nightly_tag.result == 'success' || needs.create_nightly_tag.result == 'skipped') &&
      (
        github.event_name == 'schedule' ||
        (startsWith(github.ref, 'refs/tags/') && contains(github.ref, 'dev'))
      )

    # Set up permissions for OIDC authentication
    permissions:
      id-token: write  # Required for Trusted Publishing

    steps:
      - name: Download all wheels for TestPyPI
        uses: actions/download-artifact@v4
        with:
          path: dist/
          merge-multiple: true

      - name: Publish wheels to Test PyPI
        uses: pypa/gh-action-pypi-publish@release/v1.8
        with:
          packages-dir: dist/
          verbose: true
          skip-existing: true
          repository-url: https://test.pypi.org/legacy/

  deploy_pypi:
    name: Publish all wheels to PyPI
    runs-on: ubuntu-latest
    needs:
      - determine_matrix
      - build_wheels
      - build_umep  # UMEP builds (rc1 variants)
      - create_nightly_tag  # Will be skipped for non-nightly builds
    # Only run for tagged releases WITHOUT 'dev' in the tag name
    # Deploy only if BOTH standard AND UMEP builds succeed (complete release)
    if: |
      always() &&
      startsWith(github.ref, 'refs/tags') &&
      !contains(github.ref, 'dev') &&
      needs.build_wheels.result == 'success' &&
      needs.build_umep.result == 'success' &&
      (needs.create_nightly_tag.result == 'success' || needs.create_nightly_tag.result == 'skipped')

    # Set up permissions for OIDC authentication
    permissions:
      id-token: write  # Required for Trusted Publishing

    steps:
      - name: Download all the built wheels (standard + UMEP)
        uses: actions/download-artifact@v4
        with:
          path: dist/
          merge-multiple: true

      - name: Publish all wheels to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1.8
        with:
          packages-dir: dist/
          verbose: true
          skip-existing: true

  create_github_release:
    name: Create GitHub Release (triggers Zenodo)
    runs-on: ubuntu-latest
    needs:
      - deploy_pypi
    # Run whenever PyPI deployment succeeds (already ensures it's a production tag)
    if: always() && needs.deploy_pypi.result == 'success'

    permissions:
      contents: write  # Required to create releases

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract version from tag
        id: get_version
        run: |
          VERSION=${GITHUB_REF#refs/tags/}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Extract changelog for this version
        id: changelog
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"

          # Extract the date from version (YYYY.M.D format)
          YEAR=$(echo $VERSION | cut -d. -f1)
          MONTH=$(echo $VERSION | cut -d. -f2)
          DAY=$(echo $VERSION | cut -d. -f3)

          # Try different date formats in CHANGELOG.md
          # Format: "### D MMM YYYY" or "### DD MMM YYYY"
          MONTH_NAME=$(date -d "$YEAR-$MONTH-$DAY" +"%b" 2>/dev/null || date -j -f "%Y-%m-%d" "$YEAR-$MONTH-$DAY" +"%b" 2>/dev/null || echo "")

          if [ -n "$MONTH_NAME" ]; then
            # Try with and without leading zero
            CHANGELOG_SECTION=$(awk "/^### $DAY $MONTH_NAME $YEAR/,/^### [0-9]/" CHANGELOG.md | sed '$d' || echo "")
            if [ -z "$CHANGELOG_SECTION" ]; then
              # Try with zero-padded day
              DAY_PADDED=$(printf "%02d" $DAY)
              CHANGELOG_SECTION=$(awk "/^### $DAY_PADDED $MONTH_NAME $YEAR/,/^### [0-9]/" CHANGELOG.md | sed '$d' || echo "")
            fi
          fi

          if [ -z "$CHANGELOG_SECTION" ]; then
            CHANGELOG_SECTION="See [CHANGELOG.md](https://github.com/UMEP-dev/SUEWS/blob/master/CHANGELOG.md) for details."
          fi

          # Save to file for multiline content
          echo "$CHANGELOG_SECTION" > changelog_section.txt

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          CHANGELOG=$(cat changelog_section.txt)

          # Create release notes
          cat << EOF > release_notes.md
          ## Installation
          \`\`\`bash
          pip install --upgrade supy
          \`\`\`

          ## Changes

          $CHANGELOG

          ## Citation

          This release is automatically archived on Zenodo and assigned a DOI for academic citation. The DOI will appear here once Zenodo processing is complete (usually within a few minutes).

          ## Documentation

          - [User Guide](https://suews.readthedocs.io)
          - [CHANGELOG](https://github.com/UMEP-dev/SUEWS/blob/master/CHANGELOG.md)
          - [GitHub Repository](https://github.com/UMEP-dev/SUEWS)
          EOF

          # Extract title from tag annotation if available
          TITLE=$(git tag -l --format='%(contents:subject)' "$VERSION" || echo "SUEWS Release")

          # Create the release
          gh release create "$VERSION" \
            --title "SUEWS v$VERSION: $TITLE" \
            --notes-file release_notes.md \
            --verify-tag
