name: Verify PR Builds

# This workflow provides a stable check for branch protection.
# It ALWAYS runs for PRs (no path filters) to provide a consistent gate,
# while the actual build workflow keeps its path filters to save CI resources.

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
    # NO path filters - must always run to provide gate for branch protection

  # Also run when build workflow completes to update status quickly
  workflow_run:
    workflows: ["Build and Publish Python wheels to PyPI and TestPyPI"]
    types: [completed]

jobs:
  verify-builds:
    name: Verify builds for merge
    runs-on: ubuntu-latest
    # Only run for PRs or when build workflow completes from a PR
    # Skip workflow_run events from schedule/push/tags to avoid wasted CI
    if: |
      github.event_name == 'pull_request' ||
      (github.event_name == 'workflow_run' &&
       github.event.workflow_run.event == 'pull_request')
    steps:
      - name: Check if build workflow was triggered
        id: check-builds
        uses: actions/github-script@v7
        with:
          script: |
            const BUILD_WORKFLOW_PATH = '.github/workflows/build-publish_to_pypi.yml';

            // Paths that require builds (must match build workflow path filters)
            const CODE_PATHS = [
              'src/suews/',
              'src/supy/',
              'src/supy_driver/',
              '.github/workflows/build-publish_to_pypi.yml',
              'test/',
              'pyproject.toml',
              'meson.build',
              'Makefile'
            ];

            // Determine the commit SHA and PR number
            let sha, prNumber;
            if (context.eventName === 'pull_request') {
              sha = context.payload.pull_request.head.sha;
              prNumber = context.payload.pull_request.number;
            } else if (context.eventName === 'workflow_run') {
              sha = context.payload.workflow_run.head_sha;
              // Extract PR number from workflow_run
              const prMatch = context.payload.workflow_run.head_branch.match(/^pull\/(\d+)\/merge$/);
              if (prMatch) {
                prNumber = parseInt(prMatch[1]);
              } else {
                // Try to find PR from commit
                const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  commit_sha: sha
                });
                prNumber = prs.length > 0 ? prs[0].number : null;
              }
            } else {
              core.setFailed('Unexpected event type');
              return;
            }

            const { owner, repo } = context.repo;

            // Get all workflow runs for this commit
            const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
              owner,
              repo,
              head_sha: sha,
              per_page: 100
            });

            // Find the build workflow run by PATH (stable identifier, not mutable name)
            const buildWorkflow = runs.workflow_runs.find(run =>
              run.path === BUILD_WORKFLOW_PATH &&
              run.event === 'pull_request'
            );

            if (!buildWorkflow) {
              console.log('⚠️  No build workflow run found for this commit');

              // SECURITY: Verify this is truly a doc-only PR
              // A malicious PR could disable builds, so we must check the file list
              if (!prNumber) {
                core.setFailed('Cannot find PR number to verify file changes - blocking merge for safety');
                return;
              }

              // Get changed files in the PR
              const { data: files } = await github.rest.pulls.listFiles({
                owner,
                repo,
                pull_number: prNumber,
                per_page: 100
              });

              console.log(`PR changes ${files.length} files`);

              // Check if any changed files match code paths
              const codeChanges = files.filter(file =>
                CODE_PATHS.some(pattern => {
                  // Simple prefix matching (pattern ending with / matches directory)
                  if (pattern.endsWith('/')) {
                    return file.filename.startsWith(pattern);
                  }
                  // Exact file match
                  return file.filename === pattern;
                })
              );

              if (codeChanges.length > 0) {
                console.log('✗ PR modifies code files but build workflow did not run!');
                console.log('Changed code files:', codeChanges.map(f => f.filename).join(', '));
                core.setFailed(
                  'Build workflow did not run despite code changes. ' +
                  'This could indicate: (1) build workflow was disabled/modified in PR, ' +
                  '(2) GitHub failed to queue the workflow, or ' +
                  '(3) workflow trigger conditions were changed. ' +
                  'Blocking merge for safety.'
                );
                return;
              }

              console.log('✓ PR only modifies documentation/non-code files - allowing merge');
              return;
            }

            console.log(`Build workflow found: ${buildWorkflow.html_url}`);
            console.log(`Status: ${buildWorkflow.status}, Conclusion: ${buildWorkflow.conclusion}`);

            // If workflow is still running, fail and wait for workflow_run to re-trigger us
            if (buildWorkflow.status !== 'completed') {
              console.log('Build workflow is still running...');
              core.setFailed('Build workflow is still running. This check will pass once builds complete successfully.');
              return;
            }

            // Check the conclusion
            if (buildWorkflow.conclusion === 'success') {
              console.log('✓ All builds passed');
              return;
            } else if (buildWorkflow.conclusion === 'skipped') {
              console.log('✓ Builds skipped - allowing merge');
              return;
            } else {
              console.log(`✗ Builds ${buildWorkflow.conclusion}`);
              core.setFailed(`Build workflow failed with conclusion: ${buildWorkflow.conclusion}`);
            }
