name: Build and Publish Python wheels to PyPI and TestPyPI

# ============================================================================
# WORKFLOW OVERVIEW
# ============================================================================
# This workflow handles all Python package builds and deployments for SUEWS/SuPy.
#
# TRIGGERS:
# - Nightly: 2 AM UTC daily for development releases
# - Tags: Any tag push (for releases to PyPI/TestPyPI)
# - PR: On pull requests for validation (strict mode ensures up-to-date)
# - Merge queue: On merge_group events for queue validation
# - Manual: Via workflow_dispatch
# - Master push: SKIPPED (PR already validated, no deployment needed)
#
# DEPLOYMENT STRATEGY:
# 1. VALIDATION ONLY (no deployment):
#    - Pull requests (draft): Minimal matrix (manylinux only, bookend Python 3.9 + 3.14)
#    - Pull requests (ready): Reduced matrix (ARM Mac + Linux + Windows, Python 3.9 + 3.14)
#    - Manual workflow_dispatch: Configurable matrix and deployment target (see below)
#
# 2. DEVELOPMENT RELEASES (TestPyPI only):
#    - Nightly cron (2 AM UTC, master branch only): Creates YYYY.M.D.dev tag → TestPyPI
#    - Builds TWO versions: standard (YYYY.M.D.dev0) + UMEP (YYYY.M.D.dev1)
#    - Both deployed to TestPyPI for comprehensive nightly testing
#    Installation:
#      Latest dev (NumPy 2.x): pip install -i https://test.pypi.org/simple/ supy
#      UMEP variant (NumPy 1.x): pip install -i https://test.pypi.org/simple/ supy==YYYY.M.D.dev1
#
# 3. PRODUCTION RELEASES (PyPI only):
#    - Tags without 'dev': Deploy to PyPI
#    Installation: pip install supy
#
# ============================================================================
# MANUAL DISPATCH OPTIONS (workflow_dispatch)
# ============================================================================
# When triggering manually via Actions tab, configure:
#
# MATRIX CONFIGURATION:
#   matrix_config: Choose preset or 'custom' for individual toggles
#     - full:    All platforms (Linux, macOS Intel, macOS ARM, Windows), Python 3.9-3.14
#     - pr:      Reduced (Linux, macOS ARM, Windows), Python 3.9 + 3.14
#     - minimal: Linux only, Python 3.9 + 3.14
#     - custom:  Use individual platform/Python toggles below
#
#   Platform toggles (when matrix_config=custom):
#     - plat_linux:       Linux/manylinux x86_64
#     - plat_macos_intel: macOS Intel x86_64
#     - plat_macos_arm:   macOS ARM64 (Apple Silicon)
#     - plat_windows:     Windows AMD64
#
#   Python toggles (when matrix_config=custom):
#     - py39, py310, py311, py312, py313, py314
#
# OTHER OPTIONS:
#   deploy_target: Where to publish built wheels
#     - none:     Validation only (default)
#     - testpypi: Deploy to TestPyPI
#     (PyPI deployment restricted to tagged releases only)
#
#   include_umep: Build UMEP variant (NumPy 1.x compatible)
#     - true:  Build standard + UMEP wheels (default)
#     - false: Build standard wheels only
#
#   test_tier: Test suite level
#     - all:      Full test suite (default)
#     - standard: All except slow tests
#     - core:     Core physics tests
#     - cfg:      Configuration tests
#     - smoke:    Critical tests only
#
# ============================================================================
# VERSIONING SYSTEM FOR NIGHTLY BUILDS
# ============================================================================
# Tag Format: YYYY.M.D.dev (e.g., 2025.8.17.dev)
# Published Version: YYYY.M.D.devN where N is commit count since tag
#   - At tag: 2025.8.17.dev0
#   - After 2 commits: 2025.8.17.dev2
#
# CRITICAL: Tag MUST be created BEFORE building wheels to ensure version consistency.
# Previously, creating tags after builds caused version mismatches where Aug 16 builds
# would use Aug 15 tag + commits, resulting in wrong version numbers on TestPyPI.
#
# WORKFLOW ORDER (for nightly builds):
# 1. create_nightly_tag: Creates today's tag (e.g., 2025.8.17.dev)
# 2. build_wheels: Builds using the new tag (produces 2025.8.17.dev0)
# 3. deploy_testpypi: Publishes correct version to TestPyPI
#
# RESILIENCE FEATURES:
# - Tags created even if some platform builds fail (maintains consecutive dates)
# - TestPyPI deployment proceeds with available wheels
# - Prevents gaps in nightly build sequence
#
# BUILD MATRIX STRATEGY:
# - Draft PR: Minimal (manylinux only, Python 3.9 + 3.14) for fastest feedback
# - Ready PR: Reduced (ARM Mac + Linux + Windows, Python 3.9 + 3.14) for speed with coverage
# - Tags/Nightly/Manual: Full (all platforms including x86_64 Mac, Python 3.9-3.14) for releases
# - UMEP builds: Python 3.12 only on all platforms (aligned with QGIS 3.40 LTR)
#
# ============================================================================
# UMEP/QGIS COMPATIBILITY BUILDS (rc1 pre-release versions)
# ============================================================================
# Every formal release tag automatically creates TWO PyPI versions:
#
# 1. STANDARD BUILD (build_wheels job):
#    - Tag: v2024.10.7
#    - Version: 2024.10.7
#    - NumPy: >=2.0 (build and runtime)
#    - Target: Standalone Python users
#    - Public facing, documented
#    - pip install supy → gets this version
#
# 2. UMEP BUILD (build_umep job):
#    - Tag: v2024.10.7 (same tag)
#    - Version: 2024.10.7rc1
#    - NumPy: oldest-supported-numpy (build), >=1.22,<2.0 (runtime)
#    - Target: QGIS 3.40 LTR (NumPy 1.26.4) / UMEP plugin users
#    - Undocumented publicly, for UMEP requirements files only
#    - Pre-release tag (rc1) ensures pip skips it by default
#
# AUTOMATIC DUAL BUILD PROCESS:
# - Jobs run in parallel for efficiency
# - BUILD_UMEP_VARIANT env var triggers rc1 suffix in get_ver_git.py
# - pyproject.toml modified for NumPy 1.x at build time
# - Both wheel sets deployed to PyPI together (production tags only)
# - UMEP builds use Python 3.12 only (aligned with QGIS 3.40 LTR bundled Python)
# - UMEP build triggers:
#   * PRs: win cp312 ONLY when fortran/build-system changed (compiled extension ABI)
#   * Master/manual: win cp312 (continuous UMEP compatibility testing)
#   * Nightly/dev tags: win cp312 (daily testing, uses .dev1 to avoid version collision)
#   * Production tags: all platforms cp312 (complete distribution -> PyPI, uses rc1 suffix)
#
# UMEP INTEGRATION:
# - Production: UMEP requirements specify supy==2024.10.7rc1
# - Nightly testing: UMEP developers can test with supy==2025.10.15.dev1
# - UMEP users install via UMEP requirements, never see version details
# - Versioning strategy (see get_ver_git.py):
#   * Production: X.Y.Zrc1 (pre-release for QGIS compatibility)
#   * Dev/nightly: X.Y.Z.dev1 (standard uses .dev0, UMEP uses .dev1)
# - No coordination needed - rc1 always exists for every production release
#
# VERSIONING:
# - rc1 is PEP 440 compliant pre-release version (release candidate 1)
# - Pre-releases are skipped by default: pip install supy → 2024.10.7 (not rc1)
# - Indicates alternative build config (NumPy 1.x), not unstable software
# - See get_ver_git.py for version string logic
# ============================================================================

on:
  push:
    # Skip builds for regular master pushes - PR already validated code
    # Only build when deploying: tags trigger builds for PyPI/TestPyPI
    tags:
      - '*'  # Trigger on any tag push (no path filter - tags = releases, build everything)

  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
    # No path filters - workflow ALWAYS runs for branch protection
    # Path detection happens in detect-changes job (secure, inside workflow)

  merge_group:
    # Handle merge queue validation - required for merge queue to work
    types: [checks_requested]

  schedule:
    # Run nightly builds at 2 AM UTC
    - cron: '0 2 * * *'

  workflow_dispatch:
    inputs:
      # Matrix presets
      matrix_config:
        description: 'Build matrix (custom = use toggles below)'
        required: true
        default: 'full'
        type: choice
        options:
          - full      # All platforms, all Python versions
          - pr        # Reduced: ARM Mac + Linux + Windows, Python 3.9 + 3.14
          - minimal   # Manylinux only, Python 3.9 + 3.14
          - custom    # Use individual toggles below

      # Platform toggles (only when matrix_config=custom)
      plat_linux:
        description: '[custom] Linux (manylinux x86_64)'
        type: boolean
        default: true
      plat_macos_intel:
        description: '[custom] macOS Intel (x86_64)'
        type: boolean
        default: false
      plat_macos_arm:
        description: '[custom] macOS ARM (arm64)'
        type: boolean
        default: true
      plat_windows:
        description: '[custom] Windows (AMD64)'
        type: boolean
        default: true

      # Python version toggles (only when matrix_config=custom)
      py39:
        description: '[custom] Python 3.9'
        type: boolean
        default: true
      py310:
        description: '[custom] Python 3.10'
        type: boolean
        default: false
      py311:
        description: '[custom] Python 3.11'
        type: boolean
        default: false
      py312:
        description: '[custom] Python 3.12'
        type: boolean
        default: false
      py313:
        description: '[custom] Python 3.13'
        type: boolean
        default: false
      py314:
        description: '[custom] Python 3.14'
        type: boolean
        default: true

      # Other options
      deploy_target:
        description: 'Deployment target (PyPI requires tagged release)'
        required: true
        default: 'none'
        type: choice
        options:
          - none      # Validation only
          - testpypi  # Deploy to TestPyPI
      include_umep:
        description: 'Build UMEP variant (NumPy 1.x compatible)'
        required: true
        default: true
        type: boolean
      test_tier:
        description: 'Test suite level'
        required: true
        default: 'all'
        type: choice
        options:
          - all       # Full test suite
          - standard  # All except slow tests
          - core      # Core physics tests
          - cfg       # Configuration tests
          - smoke     # Critical tests only

# Cancel in-progress runs when new commits are pushed to the same PR/branch
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  # Create nightly tag BEFORE building to ensure correct version
  create_nightly_tag:
    name: Create nightly tag for scheduled builds
    runs-on: ubuntu-latest
    # Only run for scheduled (nightly) builds
    if: github.event_name == 'schedule'
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create and push nightly tag
        run: |
          set -e

          # Get the current date in YYYY.M.D format (without leading zeros as requested)
          YEAR=$(date -u +%Y)
          MONTH=$(date -u +%-m)  # Without leading zero
          DAY=$(date -u +%-d)    # Without leading zero

          # Create a dev tag for the nightly build
          DEV_TAG="${YEAR}.${MONTH}.${DAY}.dev"
          echo "Creating dev tag: ${DEV_TAG}"

          # Configure git
          git config user.name github-actions
          git config user.email github-actions@github.com

          # Check if tag already exists
          if git ls-remote --tags origin | grep -q "refs/tags/${DEV_TAG}"; then
            echo "Tag ${DEV_TAG} already exists on remote, skipping tag creation"
          else
            # Create and push the tag
            git tag -a "${DEV_TAG}" -m "Nightly build ${YEAR}-${MONTH}-${DAY}"
            git push origin "${DEV_TAG}"
            echo "Successfully created and pushed tag ${DEV_TAG}"
          fi

  # Detect if code changes require builds (PR branch protection security)
  detect-changes:
    name: Detect code changes
    runs-on: ubuntu-latest
    # Only run for pull requests and merge queue (push/tag/schedule always build)
    if: github.event_name == 'pull_request' || github.event_name == 'merge_group'
    outputs:
      needs-build: ${{ steps.decide.outputs.needs-build }}
      needs-umep-build: ${{ steps.decide.outputs.needs-umep-build }}
      fortran-changed: ${{ steps.filter.outputs.fortran }}
      python-changed: ${{ steps.decide.outputs.python-changed }}
      util-changed: ${{ steps.filter.outputs.util }}
      build-changed: ${{ steps.decide.outputs.build-changed }}
      ci-changed: ${{ steps.filter.outputs.ci }}
      tests-changed: ${{ steps.filter.outputs.tests }}
      docs-changed: ${{ steps.filter.outputs.docs }}
      site-changed: ${{ steps.filter.outputs.site }}
      # Per-category file lists for CI summary comment
      fortran-files: ${{ steps.filter.outputs.fortran_files }}
      python-files: ${{ steps.filter.outputs.python_files }}
      util-files: ${{ steps.filter.outputs.util_files }}
      build-files: ${{ steps.filter.outputs.build_files }}
      ci-files: ${{ steps.filter.outputs.ci_files }}
      tests-files: ${{ steps.filter.outputs.tests_files }}
      docs-files: ${{ steps.filter.outputs.docs_files }}
      site-files: ${{ steps.filter.outputs.site_files }}
      pyproject-files: ${{ steps.filter.outputs.pyproject_files }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history needed for pyproject.toml content classification

      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: .github/path-filters.yml
          list-files: 'json'

      # Content-aware classification of pyproject.toml changes.
      # Only [build-system] and [tool.cibuildwheel] need multiplatform builds.
      # [project] dependencies/requires-python need single-platform (metadata).
      # Everything else (tool.ruff, optional-dependencies, etc.) needs no build.
      #
      # Requires Python >= 3.11 for tomllib (ubuntu-latest ships 3.12+).
      # Falls back to conservative "build everything" if tomllib is unavailable.
      - name: Classify pyproject.toml changes
        id: classify-pyproject
        if: steps.filter.outputs.pyproject == 'true'
        env:
          BASE_SHA: ${{ github.event.pull_request.base.sha || github.event.merge_group.base_sha }}
        run: python3 .github/scripts/classify_pyproject.py

      # Compose final outputs from path filter + pyproject classification
      - name: Compute build decision
        id: decide
        run: |
          # Compose build-changed and python-changed from path filter + pyproject
          BUILD_CHANGED=false
          if [[ "${{ steps.filter.outputs.build }}" == "true" ]] || \
             [[ "${{ steps.classify-pyproject.outputs.build_relevant || 'false' }}" == "true" ]]; then
            BUILD_CHANGED=true
          fi
          echo "build-changed=$BUILD_CHANGED" >> $GITHUB_OUTPUT

          PYTHON_CHANGED=false
          if [[ "${{ steps.filter.outputs.python }}" == "true" ]] || \
             [[ "${{ steps.classify-pyproject.outputs.package_relevant || 'false' }}" == "true" ]]; then
            PYTHON_CHANGED=true
          fi
          echo "python-changed=$PYTHON_CHANGED" >> $GITHUB_OUTPUT

          # needs-build: any build-triggering category changed
          FORTRAN="${{ steps.filter.outputs.fortran }}"
          UTIL="${{ steps.filter.outputs.util }}"
          CI="${{ steps.filter.outputs.ci }}"
          TESTS="${{ steps.filter.outputs.tests }}"

          NEEDS_BUILD=false
          if [[ "$FORTRAN" == "true" ]] || \
             [[ "$PYTHON_CHANGED" == "true" ]] || \
             [[ "$UTIL" == "true" ]] || \
             [[ "$BUILD_CHANGED" == "true" ]] || \
             [[ "$CI" == "true" ]] || \
             [[ "$TESTS" == "true" ]]; then
            NEEDS_BUILD=true
          fi
          echo "needs-build=$NEEDS_BUILD" >> $GITHUB_OUTPUT

          # needs-umep-build: only when compiled extension ABI may differ
          # (fortran source or build system changes affect NumPy 1.x vs 2.x linkage)
          NEEDS_UMEP_BUILD=false
          if [[ "$FORTRAN" == "true" ]] || \
             [[ "$BUILD_CHANGED" == "true" ]]; then
            NEEDS_UMEP_BUILD=true
          fi
          echo "needs-umep-build=$NEEDS_UMEP_BUILD" >> $GITHUB_OUTPUT

  # Determine if we should run limited or full matrix
  determine_matrix:
    name: Determine build matrix
    runs-on: ubuntu-latest
    needs: [detect-changes]
    # Always run - detect-changes is skipped for non-PR events, but we still need matrix
    if: always() && (needs.detect-changes.result == 'success' || needs.detect-changes.result == 'skipped')
    outputs:
      buildplat: ${{ steps.set-matrix.outputs.buildplat }}
      python: ${{ steps.set-matrix.outputs.python }}
      umep_buildplat: ${{ steps.set-matrix.outputs.umep_buildplat }}
      umep_python: ${{ steps.set-matrix.outputs.umep_python }}
      test_tier: ${{ steps.set-matrix.outputs.test_tier }}
    steps:
      - name: Set matrix based on trigger type
        id: set-matrix
        run: |
          # Platform presets
          FULL_PLATFORMS='[["ubuntu-latest", "manylinux", "x86_64"], ["macos-15-intel", "macosx", "x86_64"], ["macos-latest", "macosx", "arm64"], ["windows-2025", "win", "AMD64"]]'
          PR_PLATFORMS='[["ubuntu-latest", "manylinux", "x86_64"], ["macos-latest", "macosx", "arm64"], ["windows-2025", "win", "AMD64"]]'
          MINIMAL_PLATFORMS='[["ubuntu-latest", "manylinux", "x86_64"]]'

          # Python version presets
          BOOKEND_PYTHON='["cp39", "cp314"]'
          ALL_PYTHON='["cp39", "cp310", "cp311", "cp312", "cp313", "cp314"]'

          FORTRAN_CHANGED="${{ needs.detect-changes.outputs.fortran-changed || 'false' }}"
          PYTHON_CHANGED="${{ needs.detect-changes.outputs.python-changed || 'false' }}"
          UTIL_CHANGED="${{ needs.detect-changes.outputs.util-changed || 'false' }}"
          BUILD_CHANGED="${{ needs.detect-changes.outputs.build-changed || 'false' }}"

          # Multiplatform needed when compiled extension might change
          # (fortran source or build system -- not CI workflow tweaks)
          NEEDS_MULTIPLATFORM=false
          if [[ "$FORTRAN_CHANGED" == "true" ]] || [[ "$BUILD_CHANGED" == "true" ]]; then
            NEEDS_MULTIPLATFORM=true
          fi

          # Matrix strategy by event type:
          #   Draft PR:  minimal/reduced platforms, bookend Python, light tests
          #   Ready PR:  reduced/minimal platforms, bookend Python, standard/smoke tests
          #   Merge queue: reduced platforms, bookend Python, standard tests
          #   Schedule/tags: full platforms, all Python, all tests
          #   Dispatch: configurable

          if [[ "${{ github.event_name }}" == "pull_request" ]] && [[ "${{ github.event.pull_request.draft }}" == "true" ]]; then
            if [[ "$FORTRAN_CHANGED" == "true" ]]; then
              echo "Draft PR with fortran changes - reduced platforms, core tests"
              echo "buildplat=$PR_PLATFORMS" >> $GITHUB_OUTPUT
              echo "test_tier=core" >> $GITHUB_OUTPUT
            elif [[ "$BUILD_CHANGED" == "true" ]]; then
              echo "Draft PR with build-system changes - reduced platforms, cfg tests"
              echo "buildplat=$PR_PLATFORMS" >> $GITHUB_OUTPUT
              echo "test_tier=cfg" >> $GITHUB_OUTPUT
            else
              echo "Draft PR with python/util/ci/tests changes - minimal platform, smoke tests"
              echo "buildplat=$MINIMAL_PLATFORMS" >> $GITHUB_OUTPUT
              echo "test_tier=smoke" >> $GITHUB_OUTPUT
            fi
            echo "python=$BOOKEND_PYTHON" >> $GITHUB_OUTPUT

          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            TIER=standard
            if [[ "$NEEDS_MULTIPLATFORM" == "true" ]]; then
              echo "Ready PR with fortran/build changes - reduced platforms, standard tests"
              echo "buildplat=$PR_PLATFORMS" >> $GITHUB_OUTPUT
            elif [[ "$PYTHON_CHANGED" == "true" ]] || [[ "$UTIL_CHANGED" == "true" ]]; then
              echo "Ready PR with python/util changes - minimal platform, standard tests"
              echo "buildplat=$MINIMAL_PLATFORMS" >> $GITHUB_OUTPUT
            else
              echo "Ready PR with ci/tests-only changes - minimal platform, smoke tests"
              echo "buildplat=$MINIMAL_PLATFORMS" >> $GITHUB_OUTPUT
              TIER=smoke
            fi
            echo "python=$BOOKEND_PYTHON" >> $GITHUB_OUTPUT
            echo "test_tier=$TIER" >> $GITHUB_OUTPUT

          elif [[ "${{ github.event_name }}" == "merge_group" ]]; then
            echo "Merge queue validation - reduced platforms, standard tests"
            echo "buildplat=$PR_PLATFORMS" >> $GITHUB_OUTPUT
            echo "python=$BOOKEND_PYTHON" >> $GITHUB_OUTPUT
            echo "test_tier=standard" >> $GITHUB_OUTPUT

          elif [[ "${{ github.event_name }}" == "schedule" ]]; then
            echo "Nightly - full matrix, all tests"
            echo "buildplat=$FULL_PLATFORMS" >> $GITHUB_OUTPUT
            echo "python=$ALL_PYTHON" >> $GITHUB_OUTPUT
            echo "test_tier=all" >> $GITHUB_OUTPUT

          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            MATRIX_CONFIG="${{ inputs.matrix_config }}"

            case "$MATRIX_CONFIG" in
              full)
                echo "Manual dispatch: full matrix"
                echo "buildplat=$FULL_PLATFORMS" >> $GITHUB_OUTPUT
                echo "python=$ALL_PYTHON" >> $GITHUB_OUTPUT
                ;;
              pr)
                echo "Manual dispatch: PR-style reduced matrix"
                echo "buildplat=$PR_PLATFORMS" >> $GITHUB_OUTPUT
                echo "python=$BOOKEND_PYTHON" >> $GITHUB_OUTPUT
                ;;
              minimal)
                echo "Manual dispatch: minimal matrix"
                echo "buildplat=$MINIMAL_PLATFORMS" >> $GITHUB_OUTPUT
                echo "python=$BOOKEND_PYTHON" >> $GITHUB_OUTPUT
                ;;
              custom)
                echo "Manual dispatch: custom matrix from toggles"

                PLATFORMS="["
                [[ "${{ inputs.plat_linux }}" == "true" ]] && PLATFORMS+='["ubuntu-latest", "manylinux", "x86_64"],'
                [[ "${{ inputs.plat_macos_intel }}" == "true" ]] && PLATFORMS+='["macos-15-intel", "macosx", "x86_64"],'
                [[ "${{ inputs.plat_macos_arm }}" == "true" ]] && PLATFORMS+='["macos-latest", "macosx", "arm64"],'
                [[ "${{ inputs.plat_windows }}" == "true" ]] && PLATFORMS+='["windows-2025", "win", "AMD64"],'
                PLATFORMS="${PLATFORMS%,}]"

                PYTHONS="["
                [[ "${{ inputs.py39 }}" == "true" ]] && PYTHONS+='"cp39",'
                [[ "${{ inputs.py310 }}" == "true" ]] && PYTHONS+='"cp310",'
                [[ "${{ inputs.py311 }}" == "true" ]] && PYTHONS+='"cp311",'
                [[ "${{ inputs.py312 }}" == "true" ]] && PYTHONS+='"cp312",'
                [[ "${{ inputs.py313 }}" == "true" ]] && PYTHONS+='"cp313",'
                [[ "${{ inputs.py314 }}" == "true" ]] && PYTHONS+='"cp314",'
                PYTHONS="${PYTHONS%,}]"

                if [[ "$PLATFORMS" == "[]" ]]; then
                  echo "::error::Custom matrix requires at least one platform"
                  exit 1
                fi
                if [[ "$PYTHONS" == "[]" ]]; then
                  echo "::error::Custom matrix requires at least one Python version"
                  exit 1
                fi

                echo "buildplat=$PLATFORMS" >> $GITHUB_OUTPUT
                echo "python=$PYTHONS" >> $GITHUB_OUTPUT
                ;;
            esac
            echo "test_tier=${{ inputs.test_tier }}" >> $GITHUB_OUTPUT

          else
            # Tag pushes - full matrix for releases
            echo "Tag release - full matrix, all tests"
            echo "buildplat=$FULL_PLATFORMS" >> $GITHUB_OUTPUT
            echo "python=$ALL_PYTHON" >> $GITHUB_OUTPUT
            echo "test_tier=all" >> $GITHUB_OUTPUT
          fi

          # UMEP: Python 3.12 only (QGIS 3.40 LTR), Windows only for validation
          # Production tags use full platforms (handled in build_umep job's matrix expression)
          echo 'umep_buildplat=[["windows-2025", "win", "AMD64"]]' >> $GITHUB_OUTPUT
          echo 'umep_python=["cp312"]' >> $GITHUB_OUTPUT

  # Post a summary comment on PRs explaining what the CI will do
  post-ci-summary:
    name: Post CI summary comment
    runs-on: ubuntu-latest
    needs: [detect-changes, determine_matrix]
    # Post summary on PRs when both detection and matrix determination succeed
    if: >-
      github.event_name == 'pull_request' &&
      needs.detect-changes.result == 'success' &&
      needs.determine_matrix.result == 'success'
    permissions:
      pull-requests: write
    steps:
      - name: Post or update CI summary comment
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.issue.number;
            const isDraft = context.payload.pull_request.draft;

            // --- Collect category flags and file lists ---
            const categories = [
              { name: 'fortran',  label: 'Fortran source',     changed: '${{ needs.detect-changes.outputs.fortran-changed }}',  files: ${{ needs.detect-changes.outputs.fortran-files || '[]' }} },
              { name: 'python',   label: 'Python source',      changed: '${{ needs.detect-changes.outputs.python-changed }}',   files: ${{ needs.detect-changes.outputs.python-files || '[]' }} },
              { name: 'util',     label: 'Utility modules',    changed: '${{ needs.detect-changes.outputs.util-changed }}',     files: ${{ needs.detect-changes.outputs.util-files || '[]' }} },
              { name: 'build',    label: 'Build system',       changed: '${{ needs.detect-changes.outputs.build-changed }}',    files: ${{ needs.detect-changes.outputs.build-files || '[]' }} },
              { name: 'ci',       label: 'CI/workflows',       changed: '${{ needs.detect-changes.outputs.ci-changed }}',       files: ${{ needs.detect-changes.outputs.ci-files || '[]' }} },
              { name: 'tests',    label: 'Tests',              changed: '${{ needs.detect-changes.outputs.tests-changed }}',    files: ${{ needs.detect-changes.outputs.tests-files || '[]' }} },
              { name: 'docs',     label: 'Documentation',      changed: '${{ needs.detect-changes.outputs.docs-changed }}',     files: ${{ needs.detect-changes.outputs.docs-files || '[]' }} },
              { name: 'site',     label: 'Static site',        changed: '${{ needs.detect-changes.outputs.site-changed }}',     files: ${{ needs.detect-changes.outputs.site-files || '[]' }} },
              { name: 'pyproject', label: 'pyproject.toml',    changed: 'false',                                                files: ${{ needs.detect-changes.outputs.pyproject-files || '[]' }} },
            ];

            // --- Build the "Changed Files" section ---
            const changedCategories = categories.filter(c => c.changed === 'true' || c.files.length > 0);

            let filesSection = '';
            if (changedCategories.length === 0) {
              filesSection = '_No code changes detected (docs/site only or no matching paths)._\n';
            } else {
              for (const cat of changedCategories) {
                const count = cat.files.length;
                filesSection += `**${cat.label}** (${count} file${count !== 1 ? 's' : ''})\n`;
                // Show up to 15 files, collapse the rest
                const shown = cat.files.slice(0, 15);
                for (const f of shown) {
                  filesSection += `- \`${f}\`\n`;
                }
                if (cat.files.length > 15) {
                  filesSection += `- _...and ${cat.files.length - 15} more_\n`;
                }
                filesSection += '\n';
              }
            }

            // --- Build the "Build Configuration" section ---
            const needsBuild = '${{ needs.detect-changes.outputs.needs-build }}' === 'true';
            const needsUmep = '${{ needs.detect-changes.outputs.needs-umep-build }}' === 'true';
            const testTier = '${{ needs.determine_matrix.outputs.test_tier }}';

            // Parse platform matrix for human-readable display
            const buildplat = ${{ needs.determine_matrix.outputs.buildplat }};
            const platformNames = {
              'manylinux': 'Linux',
              'macosx': 'macOS',
              'win': 'Windows'
            };
            const archNames = {
              'x86_64': 'x86_64',
              'arm64': 'ARM64',
              'AMD64': 'x64'
            };
            const platforms = buildplat.map(p => {
              const os = platformNames[p[1]] || p[1];
              const arch = archNames[p[2]] || p[2];
              return `${os} ${arch}`;
            });

            // Parse Python versions
            const pythonVersions = ${{ needs.determine_matrix.outputs.python }};
            const pyDisplay = pythonVersions.map(v => v.replace('cp3', '3.')).join(', ');

            // Test tier descriptions
            const tierDesc = {
              'smoke': 'smoke (critical tests only)',
              'cfg': 'cfg (configuration + smoke)',
              'core': 'core (physics + smoke)',
              'standard': 'standard (all except slow)',
              'all': 'all (full suite)'
            };

            let configSection = '';
            if (!needsBuild) {
              configSection = '**No code build required** -- changes are docs/site/non-code only.\n';
            } else {
              configSection += `| | Configuration |\n`;
              configSection += `|---|---|\n`;
              configSection += `| **Platforms** | ${platforms.join(', ')} |\n`;
              configSection += `| **Python** | ${pyDisplay} |\n`;
              configSection += `| **Test tier** | ${tierDesc[testTier] || testTier} |\n`;
              configSection += `| **UMEP build** | ${needsUmep ? 'Yes (compiled extension may differ)' : 'Skipped (no ABI changes)'} |\n`;
              configSection += `| **PR status** | ${isDraft ? 'Draft (reduced matrix)' : 'Ready (standard matrix)'} |\n`;
            }

            // --- Build rationale ---
            const fortranChanged = '${{ needs.detect-changes.outputs.fortran-changed }}' === 'true';
            const buildChanged = '${{ needs.detect-changes.outputs.build-changed }}' === 'true';
            const pythonChanged = '${{ needs.detect-changes.outputs.python-changed }}' === 'true';
            const utilChanged = '${{ needs.detect-changes.outputs.util-changed }}' === 'true';
            const ciChanged = '${{ needs.detect-changes.outputs.ci-changed }}' === 'true';
            const testsChanged = '${{ needs.detect-changes.outputs.tests-changed }}' === 'true';

            let rationale = [];
            if (fortranChanged) rationale.push('Fortran source changed -> multiplatform build required');
            if (buildChanged) rationale.push('Build system changed -> multiplatform build required');
            if (pythonChanged) rationale.push('Python source changed -> single-platform build');
            if (utilChanged) rationale.push('Utility modules changed -> single-platform build');
            if (ciChanged) rationale.push('CI/workflow files changed -> validation build');
            if (testsChanged) rationale.push('Test files changed -> validation build');
            if (needsUmep) rationale.push('Compiled extension ABI may differ -> UMEP (NumPy 1.x) build included');
            if (!needsUmep && needsBuild) rationale.push('No compiled extension changes -> UMEP build skipped (nightly provides coverage)');
            if (!needsBuild) rationale.push('No build-triggering changes detected -> builds skipped');

            const rationaleSection = rationale.map(r => `- ${r}`).join('\n');

            // --- Compose the comment ---
            const marker = '<!-- ci-build-plan -->';
            const body = `${marker}
            ## CI Build Plan

            ### Changed Files

            ${filesSection}
            ### Build Configuration

            ${configSection}
            ### Rationale

            ${rationaleSection}

            ---
            <sub>Updated by CI on each push. See <a href="https://github.com/${context.repo.owner}/${context.repo.repo}/blob/${context.sha}/.github/path-filters.yml">path-filters.yml</a> for category definitions.</sub>`;

            // Dedent (template literal indentation)
            const dedented = body.replace(/^            /gm, '');

            // --- Post or update sticky comment ---
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });

            const existing = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes(marker)
            );

            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body: dedented
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: dedented
              });
            }

  build_wheels:
    name: Build wheel for ${{ matrix.python }}-${{ matrix.buildplat[1] }} ${{ matrix.buildplat[2] }}
    runs-on: ${{ matrix.buildplat[0] }}
    needs: [determine_matrix, create_nightly_tag, detect-changes]
    # Run if:
    # 1. Not a PR (push/tag/schedule always build), OR
    # 2. PR with code changes (detect-changes.outputs.needs-build == 'true')
    # 3. AND other dependencies succeeded/skipped
    if: |
      always() &&
      needs.determine_matrix.result == 'success' &&
      (needs.create_nightly_tag.result == 'success' || needs.create_nightly_tag.result == 'skipped') &&
      (needs.detect-changes.result == 'skipped' || needs.detect-changes.outputs.needs-build == 'true')
    strategy:
      matrix:
        buildplat: ${{ fromJson(needs.determine_matrix.outputs.buildplat) }}
        python: ${{ fromJson(needs.determine_matrix.outputs.python) }}

      fail-fast: false

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Build SUEWS wheels (standard variant)
        uses: ./.github/actions/build-suews
        with:
          buildplat: ${{ matrix.buildplat[0] }}
          buildplat_name: ${{ matrix.buildplat[1] }}
          buildplat_arch: ${{ matrix.buildplat[2] }}
          python: ${{ matrix.python }}
          is_umep_variant: 'false'
          wheel_name_suffix: ''
          test_tier: ${{ needs.determine_matrix.outputs.test_tier }}
          is_testpypi_build: ${{ github.event_name == 'schedule' || (startsWith(github.ref, 'refs/tags/') && contains(github.ref, 'dev')) }}
          # Enable DTS for releases (nightly + production tags), fast build for dev-facing (PRs)
          enable_dts: ${{ github.event_name == 'schedule' || startsWith(github.ref, 'refs/tags/') }}

  build_umep:
    name: Build UMEP wheel (rc1/dev1) for ${{ matrix.python }}-${{ matrix.buildplat[1] }} ${{ matrix.buildplat[2] }}
    runs-on: ${{ matrix.buildplat[0] }}
    needs: [determine_matrix, create_nightly_tag, detect-changes]
    # Run if:
    # 1. Not a PR (push/tag/schedule always build), OR
    # 2. PR with compiled extension changes (fortran/build-system)
    # 3. AND other dependencies succeeded/skipped
    # UMEP versioning:
    #   - Production tags: X.Y.Zrc1 (pre-release for QGIS)
    #   - Dev/nightly: X.Y.Z.dev1 (incremented to avoid collision with standard .dev0)
    # NOTE: Pure Python/util/ci/tests PRs skip UMEP -- the compiled extension is
    # identical regardless of NumPy version. Nightly builds provide full coverage.
    if: |
      always() &&
      needs.determine_matrix.result == 'success' &&
      (needs.create_nightly_tag.result == 'success' || needs.create_nightly_tag.result == 'skipped') &&
      (needs.detect-changes.result == 'skipped' || needs.detect-changes.outputs.needs-umep-build == 'true') &&
      (github.event_name != 'workflow_dispatch' || inputs.include_umep == true)
    strategy:
      matrix:
        # Limited matrix (manylinux cp312) for PRs/master/nightly/manual
        # Full matrix (all platforms cp312) for production tags only
        # IMPORTANT: Always use cp312 only for UMEP (QGIS 3.40 LTR compatibility)
        buildplat: ${{ (startsWith(github.ref, 'refs/tags/') && !contains(github.ref, 'dev')) && fromJson(needs.determine_matrix.outputs.buildplat) || fromJson(needs.determine_matrix.outputs.umep_buildplat) }}
        python: ${{ fromJson(needs.determine_matrix.outputs.umep_python) }}

      fail-fast: false

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Build SUEWS wheels (UMEP variant)
        uses: ./.github/actions/build-suews
        with:
          buildplat: ${{ matrix.buildplat[0] }}
          buildplat_name: ${{ matrix.buildplat[1] }}
          buildplat_arch: ${{ matrix.buildplat[2] }}
          python: ${{ matrix.python }}
          is_umep_variant: 'true'
          wheel_name_suffix: '-umep'
          test_tier: ${{ needs.determine_matrix.outputs.test_tier }}
          is_testpypi_build: ${{ github.event_name == 'schedule' || (startsWith(github.ref, 'refs/tags/') && contains(github.ref, 'dev')) }}
          # Enable DTS for releases (nightly + production tags), fast build for dev-facing (PRs)
          enable_dts: ${{ github.event_name == 'schedule' || startsWith(github.ref, 'refs/tags/') }}

  # NOTE: Documentation preview deployment moved to pages-deploy.yml
  # This consolidates all GitHub Pages content (site, schemas, docs) in one workflow

  # PR gate: single consolidated check for branch protection
  # This job ALWAYS runs for PRs and merge queue and reports pass/fail based on build results
  pr-gate:
    name: PR build validation
    runs-on: ubuntu-latest
    # Only run for pull requests and merge queue, but ALWAYS run (even if builds skip)
    if: always() && (github.event_name == 'pull_request' || github.event_name == 'merge_group')
    needs: [build_wheels, build_umep, detect-changes]
    steps:
      - name: Check build results
        run: |
          echo "=== Job Results ==="
          echo "detect-changes: ${{ needs.detect-changes.result }}"
          echo "build_wheels: ${{ needs.build_wheels.result }}"
          echo "build_umep: ${{ needs.build_umep.result }}"
          echo "needs-build: ${{ needs.detect-changes.outputs.needs-build }}"
          echo "needs-umep-build: ${{ needs.detect-changes.outputs.needs-umep-build }}"
          echo ""

          # STEP 1: Verify detect-changes succeeded
          if [[ "${{ needs.detect-changes.result }}" != "success" ]]; then
            echo "[X] Path detection failed - cannot verify PR safety"
            echo "  detect-changes result: ${{ needs.detect-changes.result }}"
            exit 1
          fi

          # Track validation status
          VALIDATION_PASSED=true

          NEEDS_BUILD="${{ needs.detect-changes.outputs.needs-build }}"
          NEEDS_UMEP_BUILD="${{ needs.detect-changes.outputs.needs-umep-build }}"

          if [[ "$NEEDS_BUILD" == "true" ]]; then
            # Standard build must always succeed when code changed
            echo "Code changes detected - validating standard build..."
            if [[ "${{ needs.build_wheels.result }}" == "success" ]]; then
              echo "[OK] Standard build passed"
            else
              echo "[X] Standard build failed"
              echo "  build_wheels: ${{ needs.build_wheels.result }}"
              VALIDATION_PASSED=false
            fi

            # UMEP build required only when compiled extension changed
            if [[ "$NEEDS_UMEP_BUILD" == "true" ]]; then
              echo "Compiled extension changed - validating UMEP build..."
              if [[ "${{ needs.build_umep.result }}" == "success" ]]; then
                echo "[OK] UMEP build passed"
              else
                echo "[X] UMEP build failed"
                echo "  build_umep: ${{ needs.build_umep.result }}"
                VALIDATION_PASSED=false
              fi
            else
              echo "No compiled extension changes - UMEP build not required"
              if [[ "${{ needs.build_umep.result }}" == "skipped" ]]; then
                echo "[OK] UMEP build correctly skipped"
              else
                echo "Note: UMEP build ran unexpectedly (result: ${{ needs.build_umep.result }})"
                # Non-fatal: accept success or skipped
                if [[ "${{ needs.build_umep.result }}" != "success" ]] && \
                   [[ "${{ needs.build_umep.result }}" != "skipped" ]]; then
                  VALIDATION_PASSED=false
                fi
              fi
            fi

          else
            # No code changes - builds should skip
            echo "No code changes - builds not required"

            if [[ "${{ needs.build_wheels.result }}" == "skipped" ]] && \
               [[ "${{ needs.build_umep.result }}" == "skipped" ]]; then
              echo "[OK] Code builds correctly skipped"
            else
              echo "Note: Unexpected build activity for non-code PR"
              echo "  build_wheels: ${{ needs.build_wheels.result }}"
              echo "  build_umep: ${{ needs.build_umep.result }}"
              # Still pass if builds succeeded (conservative)
              if [[ "${{ needs.build_wheels.result }}" != "success" ]] && \
                 [[ "${{ needs.build_wheels.result }}" != "skipped" ]]; then
                VALIDATION_PASSED=false
              fi
              if [[ "${{ needs.build_umep.result }}" != "success" ]] && \
                 [[ "${{ needs.build_umep.result }}" != "skipped" ]]; then
                VALIDATION_PASSED=false
              fi
            fi
          fi

          # NOTE: Docs build validation moved to pages-deploy.yml

          # Final result
          echo ""
          if [[ "$VALIDATION_PASSED" == "true" ]]; then
            echo "[OK] All validations passed"
            exit 0
          else
            echo "[X] Validation failed"
            exit 1
          fi

  deploy_testpypi:
    name: Publish to TestPyPI
    runs-on: ubuntu-latest
    needs:
      - determine_matrix
      - build_wheels
      - create_nightly_tag  # Will be skipped for non-nightly builds
    # Deploy to TestPyPI for nightly builds even if some platforms fail
    # This ensures continuous availability of development builds
    # Also allows manual dispatch with deploy_target == 'testpypi'
    if: |
      always() &&
      needs.build_wheels.result != 'cancelled' &&
      (needs.create_nightly_tag.result == 'success' || needs.create_nightly_tag.result == 'skipped') &&
      (
        github.event_name == 'schedule' ||
        (startsWith(github.ref, 'refs/tags/') && contains(github.ref, 'dev')) ||
        (github.event_name == 'workflow_dispatch' && inputs.deploy_target == 'testpypi')
      )

    # Set up permissions for OIDC authentication
    permissions:
      id-token: write  # Required for Trusted Publishing

    steps:
      - name: Download all wheels for TestPyPI
        uses: actions/download-artifact@v4
        with:
          path: dist/
          merge-multiple: true

      - name: Publish wheels to Test PyPI
        uses: pypa/gh-action-pypi-publish@release/v1.8
        with:
          packages-dir: dist/
          verbose: true
          skip-existing: true
          repository-url: https://test.pypi.org/legacy/

  deploy_pypi:
    name: Publish all wheels to PyPI
    runs-on: ubuntu-latest
    needs:
      - determine_matrix
      - build_wheels
      - build_umep  # UMEP builds (rc1 variants)
      - create_nightly_tag  # Will be skipped for non-nightly builds
    # Only run for tagged releases WITHOUT 'dev' in the tag name
    # Deploy only if BOTH standard AND UMEP builds succeed (complete release)
    if: |
      always() &&
      startsWith(github.ref, 'refs/tags') &&
      !contains(github.ref, 'dev') &&
      needs.build_wheels.result == 'success' &&
      needs.build_umep.result == 'success' &&
      (needs.create_nightly_tag.result == 'success' || needs.create_nightly_tag.result == 'skipped')

    # Set up permissions for OIDC authentication
    permissions:
      id-token: write  # Required for Trusted Publishing

    steps:
      - name: Download all the built wheels (standard + UMEP)
        uses: actions/download-artifact@v4
        with:
          path: dist/
          merge-multiple: true

      - name: Publish all wheels to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1.8
        with:
          packages-dir: dist/
          verbose: true
          skip-existing: true

  create_github_release:
    name: Create GitHub Release (triggers Zenodo)
    runs-on: ubuntu-latest
    needs:
      - deploy_pypi
    # Run whenever PyPI deployment succeeds (already ensures it's a production tag)
    if: always() && needs.deploy_pypi.result == 'success'

    permissions:
      contents: write  # Required to create releases

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract version from tag
        id: get_version
        run: |
          VERSION=${GITHUB_REF#refs/tags/}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Prepare release notes
        id: release_notes
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          RELEASE_FILE=".github/releases/${VERSION}.md"

          # Check if pre-prepared release notes exist (from prep-release workflow)
          if [ -f "$RELEASE_FILE" ]; then
            echo "Using pre-prepared release notes: $RELEASE_FILE"
            cp "$RELEASE_FILE" release_notes.md
          else
            echo "No pre-prepared release notes found, extracting from CHANGELOG"

            # Extract the date from version (YYYY.M.D format)
            YEAR=$(echo $VERSION | cut -d. -f1)
            MONTH=$(echo $VERSION | cut -d. -f2)
            DAY=$(echo $VERSION | cut -d. -f3)

            # Try different date formats in CHANGELOG.md
            MONTH_NAME=$(date -d "$YEAR-$MONTH-$DAY" +"%b" 2>/dev/null || date -j -f "%Y-%m-%d" "$YEAR-$MONTH-$DAY" +"%b" 2>/dev/null || echo "")

            CHANGELOG_SECTION=""
            if [ -n "$MONTH_NAME" ]; then
              CHANGELOG_SECTION=$(awk "/^### $DAY $MONTH_NAME $YEAR/,/^### [0-9]/" CHANGELOG.md | sed '$d' || echo "")
              if [ -z "$CHANGELOG_SECTION" ]; then
                DAY_PADDED=$(printf "%02d" $DAY)
                CHANGELOG_SECTION=$(awk "/^### $DAY_PADDED $MONTH_NAME $YEAR/,/^### [0-9]/" CHANGELOG.md | sed '$d' || echo "")
              fi
            fi

            if [ -z "$CHANGELOG_SECTION" ]; then
              CHANGELOG_SECTION="See [CHANGELOG.md](https://github.com/UMEP-dev/SUEWS/blob/master/CHANGELOG.md) for details."
            fi

            # Generate release notes from CHANGELOG
            cat << EOF > release_notes.md
          ## Installation

          \`\`\`bash
          pip install --upgrade supy
          \`\`\`

          ## Changes

          $CHANGELOG_SECTION

          ## Citation

          This release is automatically archived on Zenodo and assigned a DOI for academic citation. The DOI will appear here once Zenodo processing is complete (usually within a few minutes).

          ## Documentation

          - [User Guide](https://suews.readthedocs.io)
          - [CHANGELOG](https://github.com/UMEP-dev/SUEWS/blob/master/CHANGELOG.md)
          - [GitHub Repository](https://github.com/UMEP-dev/SUEWS)
          EOF
          fi

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"

          # Extract title from tag annotation if available
          TITLE=$(git tag -l --format='%(contents:subject)' "$VERSION" || echo "SUEWS Release")

          # Create the release
          gh release create "$VERSION" \
            --title "SUEWS v$VERSION: $TITLE" \
            --notes-file release_notes.md \
            --verify-tag
