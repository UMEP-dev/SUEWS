name: 'Build SUEWS Wheels'
description: 'Build SUEWS wheels with cibuildwheel and cached Rust dependencies'

inputs:
  buildplat:
    description: 'Build platform (e.g., ubuntu-latest, macos-15-intel, windows-2025)'
    required: true
  buildplat_name:
    description: 'Platform name for wheel (e.g., manylinux, macosx, win)'
    required: true
  buildplat_arch:
    description: 'Architecture (e.g., x86_64, arm64, AMD64)'
    required: true
  python:
    description: 'Python version to build for (e.g., cp39, cp310)'
    required: true
  is_umep_variant:
    description: 'Whether this is a UMEP variant build (true/false)'
    required: true
    default: 'false'
  wheel_name_suffix:
    description: 'Suffix for wheel artifact name (e.g., "", "-umep")'
    required: false
    default: ''
  test_tier:
    description: 'Test tier: smoke, core, cfg, standard, or all'
    required: false
    default: 'standard'
  is_testpypi_build:
    description: 'Whether this is a TestPyPI build (adds notice to README)'
    required: false
    default: 'false'

runs:
  using: 'composite'
  steps:
    - name: Inject TestPyPI notice into README
      if: inputs.is_testpypi_build == 'true'
      shell: bash
      run: |
        # Add TestPyPI notice after the first heading in README.md
        # This notice only appears in TestPyPI releases, not production PyPI
        # Insert after line 3 (after "This is the SUEWS urban climate model repository.")
        head -n 3 README.md > README.tmp
        # Note: Using printf to avoid YAML parsing issues with '>' at line start
        printf '\n' >> README.tmp
        printf '**TestPyPI Release**: This is a development version published to [test.pypi.org](https://test.pypi.org/project/supy/).\n' >> README.tmp
        printf 'For installation instructions, see [Testing Development Versions](https://docs.suews.io/latest/installation.html#testing-development-versions) in the documentation.\n' >> README.tmp
        tail -n +4 README.md >> README.tmp
        mv README.tmp README.md
        echo "Added TestPyPI notice to README.md"
        head -15 README.md

    - name: Modify pyproject.toml for NumPy 1.x compatibility
      if: inputs.is_umep_variant == 'true'
      shell: bash
      run: |
        echo "Building UMEP variant with NumPy 1.x compatibility"

        # Use Python for cross-platform TOML modification (BSD sed on macOS differs from GNU sed)
        # Note: Regex approach relies on pyproject.toml structure where [build-system] uses
        # 'requires' and [project] uses 'dependencies'. A TOML parser (tomli/tomllib) would
        # be more robust but adds complexity. If pyproject.toml structure changes significantly,
        # revisit this approach.
        python3 << 'EOF'
        import re

        with open('pyproject.toml', 'r') as f:
            content = f.read()

        # Runtime: Pin to NumPy 1.x (QGIS 3.40 LTR uses 1.26.4)
        # Targets [project].dependencies (not [build-system].requires)
        content = re.sub(
            r'(dependencies\s*=\s*\[.*?)"numpy>=2\.0"',
            r'\1"numpy>=1.22,<2.0"',
            content,
            flags=re.DOTALL
        )

        # Build-time: Use oldest-supported-numpy for binary compatibility
        # Targets [build-system].requires explicitly
        content = re.sub(
            r'(\[build-system\].*?requires\s*=\s*\[.*?)"numpy>=2\.0"',
            r'\1"oldest-supported-numpy"',
            content,
            flags=re.DOTALL
        )

        with open('pyproject.toml', 'w') as f:
            f.write(content)

        print("pyproject.toml modified successfully")
        EOF

        echo "Modified pyproject.toml for UMEP build:"
        git diff pyproject.toml || true

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: 3.12

    - name: Generate version file from git
      shell: bash
      env:
        BUILD_UMEP_VARIANT: ${{ inputs.is_umep_variant }}
      run: |
        # Generate version file on host (where git is available)
        # This file will be copied into the cibuildwheel container
        if [ "${{ inputs.is_umep_variant }}" = "true" ]; then
          echo "Generating version for UMEP variant (rc1 suffix)"
          export BUILD_UMEP_VARIANT=true
        fi
        python3 get_ver_git.py
        echo "Generated version: $(cat src/supy/_version_scm.py | grep __version__)"

    - name: Prepare Rust cache directories
      shell: bash
      run: mkdir -p .cargo-cache .rust-target-cache

    - name: Cache Rust/Cargo dependencies
      uses: actions/cache@v4
      with:
        path: |
          .cargo-cache
          .rust-target-cache
        key: cargo-${{ inputs.buildplat_name }}-${{ inputs.buildplat_arch }}-${{ inputs.python }}-${{ hashFiles('src/suews_bridge/Cargo.lock') }}
        restore-keys: |
          cargo-${{ inputs.buildplat_name }}-${{ inputs.buildplat_arch }}-${{ inputs.python }}-

    - name: Build wheels
      uses: pypa/cibuildwheel@v3.2
      env:
        IS_32_BIT: ${{ inputs.buildplat_arch == 'x86' }}
        BUILD_UMEP_VARIANT: ${{ inputs.is_umep_variant }}
        CIBW_BUILD: ${{ inputs.python }}-${{ inputs.buildplat_name }}*
        CIBW_ARCHS: ${{ inputs.buildplat_arch }}
        # Mount host cache directories into the Linux Docker container so that
        # cargo artifacts survive container teardown and can be saved by actions/cache.
        # cibuildwheel uses `docker cp` (not bind mount) for the project, so without
        # explicit volume mounts the compiled deps are lost when the container exits.
        CIBW_CONTAINER_ENGINE: >-
          docker; create_args:
          --volume ${{ github.workspace }}/.cargo-cache:/cargo-cache
          --volume ${{ github.workspace }}/.rust-target-cache:/rust-target-cache
        # CIBW_ENABLE: ${{ inputs.python == 'cp314' && 'cp314' || '' }}
        CIBW_ENVIRONMENT_PASS_LINUX: ${{ inputs.is_umep_variant == 'true' && 'RUNNER_OS BUILD_UMEP_VARIANT' || 'RUNNER_OS' }}
        # Use manylinux_2_28 for Python 3.13+ (newer dependencies require it), manylinux2014 for 3.9-3.12 (older Linux compatibility)
        CIBW_MANYLINUX_X86_64_IMAGE: ${{ (inputs.python == 'cp313' || inputs.python == 'cp314') && 'manylinux_2_28' || 'manylinux2014' }}
        CIBW_MANYLINUX_AARCH64_IMAGE: ${{ (inputs.python == 'cp313' || inputs.python == 'cp314') && 'manylinux_2_28' || 'manylinux2014' }}
        # Configure pip for all platforms - prefer binary wheels
        CIBW_ENVIRONMENT: >
          PIP_PREFER_BINARY=1
          ${{ inputs.is_umep_variant == 'true' && 'BUILD_UMEP_VARIANT=true' || '' }}
        # Platform-specific: Linux Fortran compiler and Rust toolchain settings
        CIBW_ENVIRONMENT_LINUX: >
          FCFLAGS="-fno-optimize-sibling-calls -ffree-line-length-none"
          F90=gfortran
          CARGO_HOME=/cargo-cache
          CARGO_TARGET_DIR=/rust-target-cache
          PATH="/cargo-cache/bin:$PATH"
        CIBW_BEFORE_ALL_LINUX: >
          curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y &&
          pip install --upgrade pip setuptools wheel &&
          if [[ "${{ inputs.is_umep_variant }}" == "true" ]]; then
            echo "Installing oldest-supported-numpy for UMEP variant build" &&
            pip install oldest-supported-numpy;
          else
            echo "Installing numpy>=2.0 for standard build" &&
            pip install 'numpy>=2.0';
          fi &&
          if [[ "${{ inputs.python }}" == "cp313" ]] || [[ "${{ inputs.python }}" == "cp314" ]]; then
            echo "Installing numpy for Python ${{ inputs.python }} build" &&
            pip install numpy;
          fi
        CIBW_BEFORE_ALL_MACOS: >
          brew install gfortran &&
          brew unlink gfortran &&
          brew link gfortran
        # Windows MSYS2/pacman setup with two workarounds:
        # 1. Core package updates (pacman, msys2-runtime) terminate bash.exe via taskkill - use Windows-level
        #    error suppression (|| ver >nul) since bash can't execute || true when forcibly killed
        # 2. Mirror timeouts cause "Operation too slow" errors - use --disable-download-timeout + retry
        CIBW_BEFORE_ALL_WINDOWS: >
          (C:\msys64\usr\bin\bash.exe -lc "pacman -Syu --noconfirm --disable-download-timeout" || ver >nul) &&
          C:\msys64\usr\bin\bash.exe -lc "pacman -Syu --noconfirm --disable-download-timeout" &&
          C:\msys64\usr\bin\bash.exe -lc "for i in 1 2 3; do pacman -S --needed --noconfirm --disable-download-timeout mingw-w64-ucrt-x86_64-gcc mingw-w64-ucrt-x86_64-gcc-fortran mingw-w64-ucrt-x86_64-binutils mingw-w64-ucrt-x86_64-make mingw-w64-ucrt-x86_64-openblas && break || { echo Retry $i/3 && sleep 15; }; done"
        # Platform-specific: Windows compiler and toolchain settings
        CIBW_ENVIRONMENT_WINDOWS: >
          PATH="C:\\msys64\\ucrt64\\bin;$PATH"
          CC=gcc
          CXX=g++
          FC=gfortran
          CFLAGS="-D__USE_MINGW_ANSI_STDIO=1 -mlong-double-64"
          CXXFLAGS="-D__USE_MINGW_ANSI_STDIO=1 -mlong-double-64"
          FCFLAGS="-fno-optimize-sibling-calls -ffree-line-length-none"
          LDFLAGS="-lucrt -static-libgcc -static-libgfortran -LC:/msys64/ucrt64/lib -lsetjmp_compat"
        CIBW_BEFORE_BUILD_WINDOWS: >
          echo Creating setjmp compatibility library... &&
          echo int _setjmpex(void* buf) { extern int __intrinsic_setjmpex(void*); return __intrinsic_setjmpex(buf); } > setjmp_compat.c &&
          C:\msys64\ucrt64\bin\gcc.exe -c setjmp_compat.c -o setjmp_compat.o &&
          C:\msys64\ucrt64\bin\ar.exe rcs libsetjmp_compat.a setjmp_compat.o &&
          echo Library created, checking contents: &&
          C:\msys64\ucrt64\bin\nm.exe libsetjmp_compat.a &&
          echo Copying to standard locations: &&
          copy libsetjmp_compat.a C:\msys64\ucrt64\lib\ &&
          copy libsetjmp_compat.a C:\msys64\ucrt64\x86_64-w64-mingw32\lib\ &&
          echo Verifying library locations: &&
          dir C:\msys64\ucrt64\lib\libsetjmp_compat.a &&
          dir C:\msys64\ucrt64\x86_64-w64-mingw32\lib\libsetjmp_compat.a &&
          where python &&
          where gcc &&
          gcc --version &&
          pip install delvewheel
        CIBW_REPAIR_WHEEL_COMMAND_WINDOWS: "delvewheel repair -w {dest_dir} {wheel}"
        # TODO: remove CIBW_TEST_SKIP after cargo cache is verified
        CIBW_TEST_SKIP: "*"
        CIBW_TEST_REQUIRES: ${{ inputs.is_umep_variant == 'true' && 'pytest numpy==1.26.*' || 'pytest' }}
        # Test tiers: choose subset based on path detection and trigger
        # Always include --durations=10 to show slowest tests in output
        # After pytest, enforce bridge-manifest coverage of public Fortran types.
        # Uses run_ci_tests.py wrapper to avoid shell-level && chaining,
        # which breaks on Windows cmd.exe with quoted marker expressions.
        CIBW_TEST_COMMAND: >-
          python {project}/scripts/run_ci_tests.py {project}
          -v --tb=short --durations=10
          ${{ inputs.test_tier == 'smoke' && '-m smoke' ||
              inputs.test_tier == 'core' && '-m "smoke or core"' ||
              inputs.test_tier == 'cfg' && '-m "smoke or cfg"' ||
              inputs.test_tier == 'standard' && '-m "not slow"' ||
              '' }}
        MACOSX_DEPLOYMENT_TARGET: '15.0'

    - name: Upload wheels
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.python }}-${{ inputs.buildplat_name }}-${{ inputs.buildplat_arch }}${{ inputs.wheel_name_suffix }}
        path: ./wheelhouse/*.whl
